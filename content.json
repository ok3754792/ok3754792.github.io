{"meta":{"title":"px-blog","subtitle":"","description":"record","author":"px","url":"pangxue.vip","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-03-26T12:21:55.148Z","updated":"2020-03-21T12:47:39.673Z","comments":false,"path":"/404.html","permalink":"pangxue.vip/404.html","excerpt":"","text":""},{"title":"书单","date":"2020-03-26T12:22:15.969Z","updated":"2020-03-21T12:47:39.676Z","comments":false,"path":"books/index.html","permalink":"pangxue.vip/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-03-21T12:47:39.675Z","updated":"2020-03-21T12:47:39.675Z","comments":false,"path":"about/index.html","permalink":"pangxue.vip/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2020-03-26T12:22:21.118Z","updated":"2020-03-21T12:47:39.677Z","comments":false,"path":"categories/index.html","permalink":"pangxue.vip/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-03-21T12:47:39.678Z","updated":"2020-03-21T12:47:39.678Z","comments":true,"path":"links/index.html","permalink":"pangxue.vip/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-03-21T12:47:39.678Z","updated":"2020-03-21T12:47:39.678Z","comments":false,"path":"repository/index.html","permalink":"pangxue.vip/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-21T12:47:39.679Z","updated":"2020-03-21T12:47:39.679Z","comments":false,"path":"tags/index.html","permalink":"pangxue.vip/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"java中的代理","slug":"java中的代理","date":"2021-04-10T17:27:53.000Z","updated":"2021-04-10T17:36:54.354Z","comments":true,"path":"2021/04/11/null/","link":"","permalink":"pangxue.vip/2021/04/11/null/","excerpt":"","text":"1.简介动态代理技术就是用来产生一个对象的代理对象的。 1、代理对象存在的价值主要用于拦截对真实业务对象的访问。 2、代理对象应该具有和目标对象(真实业务对象)相同的方法。 刘德华(真实业务对象)会唱歌，会跳舞，会拍戏，我们现在不能直接找他唱歌，跳舞，拍戏了，只能找他的代理人(代理对象)唱歌，跳舞，拍戏，一个人要想成为刘德华的代理人，那么他必须具有和刘德华一样的行为(会唱歌，会跳舞，会拍戏)，刘德华有什么方法，他(代理人)就要有什么方法，我们找刘德华的代理人唱歌，跳舞，拍戏，但是代理人不是真的懂得唱歌，跳舞，拍戏的，真正懂得唱歌，跳舞，拍戏的是刘德华，在现实中的例子就是我们要找刘德华唱歌，跳舞，拍戏，那么只能先找他的经纪人，交钱给他的经纪人，然后经纪人再让刘德华去唱歌，跳舞，拍戏。这个现实中的例子和我们在开发中是一样的，我们在开发中之所以要产生一个对象的代理对象，主要用于拦截对真实业务对象的访问。那么代理对象应该具有什么方法呢？代理对象应该具有和目标对象相同的方法 ２．Java中的动态代理： 现在要生成某一个对象的代理对象，这个代理对象通常也要编写一个类来生成，所以首先要编写用于生成代理对象的类。在java中如何用程序去生成一个对象的代理对象呢，java在JDK1.5之后提供了一个java.lang.reflect.Proxy类，通过Proxy类提供的一个newProxyInstanc方法用来创建一个对象的代理对象，，这个方法总共有3个参数，ClassLoader loader用来指明生成代理对象使用哪个类装载器，Class[] interfaces用来指明生成哪个对象的代理对象，通过接口指定，InvocationHandler 用来指明产生的这个代理对象要做什么事情。所以我们只需要调用newProxyInstance方法就可以得到某一个对象的代理对象了。在java中规定，要想产生一个对象的代理对象，那么这个对象必须要有一个接口** 3．实战(RabbitMq中的实战)： 1.定义对象接口123public interface BaseConsumer &#123; void consume(Message message, Channel channel) throws IOException;&#125; 2.定义被代理对象实现对象接口12345678public class PartsBaseToInStorageConsumer implements BaseConsumer &#123; @Override public void consume(Message message, Channel channel) &#123; log.debug(&quot;收到消息1: &#123;&#125;&quot;, message.toString()); PartsBase entity &#x3D; MessageHelper.msgToObj(message, PartsBase.class); &#x2F;&#x2F;业务逻辑 &#125; &#125; 3.定义代理类1234567891011121314151617181920212223242526272829public class BaseConsumerProxy &#123; &#x2F;&#x2F;私有属性 private Object target; private RemoteMsgLogService msgLogService; &#x2F;&#x2F;构造方法 public BaseConsumerProxy(Object target, RemoteMsgLogService msgLogService) &#123; this.target &#x3D; target; this.msgLogService &#x3D; msgLogService; &#125; &#x2F;&#x2F;获取代理对象 public Object getProxy() &#123; ClassLoader classLoader &#x3D; target.getClass().getClassLoader(); Class[] interfaces &#x3D; target.getClass().getInterfaces();return Proxy.newProxyInstance(classLoader, interfaces, (proxy, method, args) -&gt; &#123; Message message &#x3D; (Message) args[0]; Channel channel &#x3D; (Channel) args[1]; MessageProperties properties &#x3D; message.getMessageProperties(); long tag &#x3D; properties.getDeliveryTag(); try &#123; Object result &#x3D; method.invoke(target, args); channel.basicAck(tag, false); return result; &#125; catch (Exception e) &#123; log.error(&quot;getProxy error&quot;, e); return null; &#125;&#125;);&#125; 4.使用方式123456789101112@RabbitListener(queues &#x3D; PartsBaseMqConstant.PARTS_BASE_TO_IN_STORAGE_QUEUE)public void partsBaseInStorageConsume(Message message, Channel channel) throws IOException &#123; rabbitUtils.doConsume(message, channel, partsBaseInStorageConsumer);&#125;public void doConsume(Message message, Channel channel, BaseConsumer baseConsumer) throws IOException &#123; BaseConsumerProxy baseConsumerProxy &#x3D; new BaseConsumerProxy(baseConsumer, msgLogService); BaseConsumer proxy &#x3D; (BaseConsumer) baseConsumerProxy.getProxy(); if (null !&#x3D; proxy) &#123; proxy.consume(message, channel); &#125;&#125; 5.解释： 所有的对象都通过代理类来访问，我要让其中一个队列执行消费功能，那么通过公用代理类来访问，来执行mq的一些操作，比如确认消费啊，报错消费重入队列等操作，因为这些操作都是相同的逻辑所以放到公用代理类里，然后消费者就单纯的执行消费方面的逻辑，比如入库等。当然也可以每一个消费队列都一个消费代理类。","categories":[],"tags":[]},{"title":"Mysql语句","slug":"Mysql语句","date":"2021-04-10T17:03:04.000Z","updated":"2021-04-10T17:27:32.537Z","comments":true,"path":"2021/04/11/mysql/","link":"","permalink":"pangxue.vip/2021/04/11/mysql/","excerpt":"","text":"1.求每个学生所有学科分最高的是哪科？1select student.* from student inner join (select name,max(grade) grade from student group by name ) t on student.name&#x3D;t.name and student.grade&#x3D;t.grade 2.求每个学科分最高的是那个童鞋？1SELECT student.* FROM student inner JOIN ( SELECT subject, max( grade ) grade FROM student GROUP BY subject ) t ON student.subject &#x3D; t.subject AND student.grade &#x3D; t.grade 3.求数学成绩大于数学整体平均分的同学？1select student.* from student where subject &#x3D;&#39;数学&#39; and grade&gt;(select avg(grade) from student where subject&#x3D;&#39;数学&#39;) 4.求数学平均分大于60分的同学？1select student.name from student where subject&#x3D;&#39;数学&#39; group by student.&#96;name&#96; having avg(grade) &gt;60","categories":[{"name":"mysql","slug":"mysql","permalink":"pangxue.vip/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"pangxue.vip/tags/mysql/"}]},{"title":"MyBatisCodeHelper-Pro破解[2.8.1]","slug":"Mybatis-code-helper-pro破解","date":"2020-05-26T02:05:07.000Z","updated":"2020-05-26T02:08:10.005Z","comments":true,"path":"2020/05/26/MyBatisCodeHelper/","link":"","permalink":"pangxue.vip/2020/05/26/MyBatisCodeHelper/","excerpt":"","text":"链接: https://pan.baidu.com/s/1qwOzRupun3uVTw6dQMHB2g 提取码: ebcv 复制这段内容后打开百度网盘手机App，操作更方便哦 https://zhile.io/2019/04/23/mybatis-code-helper-pro-crack.html","categories":[],"tags":[{"name":"MyBatisCodeHelper","slug":"MyBatisCodeHelper","permalink":"pangxue.vip/tags/MyBatisCodeHelper/"}]},{"title":"idea配置","slug":"idea配置","date":"2020-05-21T02:17:25.000Z","updated":"2020-05-21T02:21:38.627Z","comments":true,"path":"2020/05/21/ideasetting/","link":"","permalink":"pangxue.vip/2020/05/21/ideasetting/","excerpt":"","text":"1：idea破解（更新到2020.1.1版本）1链接: https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1CjLBcqQqwQ5Olfc7bF6xwA 提取码: tifc 使用方式： 下载最新版idea，安装，然后进去试用30天，进入软件** 下载上述文件，去lib目录下解压到指定目录，将jetbrains-agent.jar拖到idea中，然后选择Active_Code方式激活即可，如果不好使参考试用说明** 2：开启服务甲板（原dashboard） 打开项目下.idea-&gt;workspace.xml,找到RunDashboard，添加如下代码保存重启即可1234567&lt;component name&#x3D;&quot;RunDashboard&quot;&gt; &lt;option name&#x3D;&quot;configurationTypes&quot;&gt; &lt;set&gt; &lt;option value&#x3D;&quot;SpringBootApplicationConfigurationType&quot; &#x2F;&gt; &lt;&#x2F;set&gt; &lt;&#x2F;option&gt;&lt;&#x2F;component&gt; 对启动的服务添加端口号：删除掉安装自带的快捷方式，把图片中的idea64发送到桌面快捷方式即可 3：集成mybatis报错使用MyBatisCodeHelperPro插件，但是使用时代码飘红，Result type is xxx, Not match for List&lt;xxx&gt;“ 4：P3C插件一款阿里爸爸的代码规范，可实时检查，下载地址：https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines","categories":[],"tags":[{"name":"idea","slug":"idea","permalink":"pangxue.vip/tags/idea/"}]},{"title":"Mysql相关","slug":"Mysql相关","date":"2020-05-19T01:09:50.000Z","updated":"2020-05-26T03:49:43.795Z","comments":true,"path":"2020/05/19/aboutmysql/","link":"","permalink":"pangxue.vip/2020/05/19/aboutmysql/","excerpt":"","text":"1. MyISAM引擎 MySQL的表级锁有两种模式：共享读锁（Read-Lock）和排它写锁（Write-Lock）。针对MyISAM表的读操作，不会阻塞其他线程对同一表的读请求，但阻塞对同一表的写请求；针对MyISAM表的写操作，会阻塞其他线程对同一表的读和写操作；MyISAM引擎读写操作之间，以及写与写操作之间是串行化。当一次会话线程获取表的写锁后，只有当前持有锁的会话线程可以对表进行操作。其它线程的读、写操作都会等待，直到锁被释放为止。 123456789101112-- 1、加读锁&#x2F;&#x2F;LOCK TABLE name [READ,WRITE] ;加表锁&#x2F;&#x2F;UNLOCK TABLES ; 释放表锁LOCK TABLE dc_user READ ;-- 2、当前会话查询，OKSELECT * FROM dc_user ;-- 4、当前会话写入，ErrorINSERT INTO dc_user (user_name,tell_phone) VALUES (&#39;lock01&#39;,&#39;13267788998&#39;);-- 6、查询其他表,ErrorSELECT * FROM dc_user_info ;-- 7、释放锁UNLOCK TABLES ; ２. InnoDB引擎InnoDB支持事物，支持行级锁 事务概念事务是指作为单个逻辑工作单元执行的一系列操作（SQL语句）。这些操作要么全部成功，要么全部不成功。 事务特性ACID 原子性(Atomicity)*：事务中的多个操作要么都成功要么都失败 一致性(consistency)*：事务的执行的前后数据的完整性保持一致 隔离性(isolation)*：事务执行的过程中,不应该受到其他事务的干扰 持久性(durability)*：事务一旦结束,数据就持久到数据库 事务问题 脏读*：一个事务读到另一个事务没有提交的数据 不可重复读*：一个事务前后多次读取相同数据，数据内容不一致，update场景问题 虚读(幻读)*：一个事务前后多次读取，数据总量不一致，insert场景问题 隔离级别 read uncommitted*：事务可以读取另一个未提交事务的数据。 read committed*：事务要等另一个事务提交后才能读取数据,解决脏读。 repeatable read*：在开始读取数据时,事务开启,不再允许修改操作,解决：脏读、不可重复读。 serializable*：最高事务隔离级别，事务串行化顺序执行，解决脏读、不可重复读、幻读。但是效率低下，耗数据库性能。 锁 1.共享锁：*又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上共享锁，则事务T可以读A但不能修改A，其他事务只能再对A加共享锁，而不能加写锁，直到T释放A上的共享锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 2.排他锁：*又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的资源的共享读锁和排他锁。若事务T对数据对象A加上写锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的写锁。123456789101112131415-- 1、关闭自动提交SET AUTOCOMMIT &#x3D; 0 ;-- 2、查询id&#x3D;2，OKSELECT * FROM dc_user_in02 WHERE id&#x3D;2 ;-- 3、查询id&#x3D;1，OK，加读锁SELECT * FROM dc_user_in02 WHERE id&#x3D;1 ;-- 4、写入成功INSERT INTO dc_user_in02 (user_name,tell_phone) VALUES (&#39;lock01&#39;,&#39;13267788998&#39;);-- 5、加写锁成功，id为2的SELECT * FROM dc_user_in02 WHERE id&#x3D;2 FOR UPDATE ;-- 6、加写锁失败(等待)，占用id为1的SELECT * FROM dc_user_in02 WHERE id&#x3D;1 FOR UPDATE ;-- 7、恢复事务提交SET AUTOCOMMIT&#x3D;1 ; 3.悲观锁适用于写操作较多，读操作较少的情况 12select * from user where uid&#x3D;l for update;&#x2F;&#x2F;行锁update user set name&#x3D;bac where uid&#x3D;l;&#x2F;&#x2F;更新完释放这条锁 4. 乐观锁乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 1、使用版本号实现乐观锁给表增加一个数字类型的 “version” 字段，当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加 1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表1update xxx set aaa&#x3D;111,version&#x3D;version+1 where id&#x3D;#&#123;id&#125; and version&#x3D;#&#123;version&#125;; 2、乐观锁锁库存防止超买超卖 version乐观锁能控制并发，但是不能控制数量的超卖问题 123456update res_stockset number &#x3D;number + #&#123;resStockVo.operateNumber&#125;, version&#x3D;#&#123;resStockVo.version&#125; + 1where id &#x3D; #&#123;resStockVo.id&#125; and number + #&#123;resStockVo.operateNumber&#125; &gt;&#x3D; 0 and version &#x3D; #&#123;resStockVo.version&#125; 3、mybatis plus实现乐观锁123456&#x2F;&#x2F;注册bean@Beanpublic OptimisticLockerInterceptor optimisticLockerInterceptor() &#123; return new OptimisticLockerInterceptor();&#125;&#x2F;&#x2F;实体里添加 @Version 注解，* 仅支持 &#96;updateById(id)&#96; 与 &#96;update(entity, wrapper)&#96; 方法 4、乐观锁添加重试机制 123456&#x2F;&#x2F;重试注解@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface OptimisticLock &#123; int retryTimes() default 3;&#125; 123456789101112131415161718192021222324252627@Slf4j@Aspect@AllArgsConstructorpublic class RetryAspect &#123; @Around(&quot;@annotation(lock)&quot;) @Transactional(rollbackFor &#x3D; Exception.class) public Object doConcurrentOperation(ProceedingJoinPoint pjp, OptimisticLock lock) throws Throwable &#123; int retryTimes &#x3D; 0; int MaxRetryTimes &#x3D; lock.retryTimes(); while (retryTimes &lt;&#x3D; MaxRetryTimes) &#123; retryTimes++; try &#123; &#x2F;&#x2F;再次执行 return pjp.proceed(); &#125; catch (OptimisticLockException ex) &#123; if (retryTimes &gt; MaxRetryTimes) &#123; &#x2F;&#x2F;如果大于默认的重试机制 次数，我们这回就真正的抛出去了 throw new RuntimeException(ex.getMessage()); &#125; else &#123; log.info(&quot;当前正在重试第：&quot; + retryTimes + &quot;次&quot;); &#125; &#125; &#125; return null; &#125;&#125; 12345&#x2F;&#x2F;注册bean@Beanpublic RetryAspect retryAspect() &#123; return new RetryAspect();&#125;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"pangxue.vip/tags/mysql/"}]},{"title":"线程相关","slug":"线程相关","date":"2020-05-08T02:26:16.000Z","updated":"2020-05-21T02:08:06.973Z","comments":true,"path":"2020/05/08/aboutthread/","link":"","permalink":"pangxue.vip/2020/05/08/aboutthread/","excerpt":"","text":"1.线程安全 线程安全：多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。 线程不安全：不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据 线程安全问题都是由多个线程访问同一个共享资源的写操作引起的。比如一个 ArrayList 类，如果是在多线程情况下，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向 ArrayList 添加元素，因为此时 Size 仍然等于 0 ，所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。 对于Integer，++ 操作是不安全的，所以java提供了原子操作类 AtomicInteger 来实现自增等操作 静态方法：如果方法内部不操作类的静态变量或者全局变量，那么该方法是线程安全的，如果操作了，那么需要加锁来实现线程安全。 解决方法： 锁：每个java对象都可以用做一个实现同步的锁，这些锁成为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。 乐观锁和悲观锁： 悲观锁：在整个数据处理过程中，将数据处于锁定状态，传统关系型数据库里面的很多锁就是采用的这种机制,例如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。java里面的synchronize和ReentrantLock等重入锁就是采用的这种机制。 乐观锁：在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现在Java中java.util.concurrent.atomic包下面的原子变量类就是使用CAS实现的：实现方式1:update t_goods set status=2,version=version+1 where id=#{id} and version=#{version};2:UPDATE t_goods SET num = num - #{buyNum} WHERE id = #{id} AND num - #{buyNum} &gt;= 0 AND STATUS = 1这两种办法都可以实现，第一种需要额外拓展一个version的字段，第二种适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高。 类锁和对象锁：synchronized 加到 static 方法前面是给 class 加锁，即类锁；而synchronized 加到非静态方法前面是给对象上锁。对象锁和类锁是不同的锁，所以多个线程同时执行这2个不同锁的方法时，是异步的。类锁对该类的所有对象都能起作用，而对象锁不能 synchronized修饰方法：直接对方法上锁，第一个线程占用之后其他线程必须等待其释放，当方法内业务逻辑复杂时，影响系统运行性能，不会出现数据脏读 12345public synchronized int increamentAndGet() &#123; System.out.println(&quot;当前余票&quot; + (100 - i)); i++; return i;&#125; synchronized修代码块：不锁方法，锁要类的对象,但是并不能保证线程调用的方法体同步执行（同步代码块中执行是同步的）,线程会优先读取被锁住的代码块，代码块内保证了真正的同步，代码块外部还是并发，就会出现数据脏读，例如下图余票 12345678public int increamentAndGet() &#123; System.out.println(&quot;当前余票&quot;+(100-i)); synchronized (this)&#123; System.out.println(&quot;当前真实的余票&quot;+(100-i)); i++; return i; &#125;&#125; lock 123456789Lock lock &#x3D; new ReentrantLock();public int increamentAndGet() &#123; System.out.println(&quot;当前余票&quot; + (100 - i)); lock.lock(); System.out.println(&quot;当前真实的余票&quot; + (100 - i)); i++; lock.unlock(); return i;&#125; 测试代码 12345678910111213141516171819202122232425262728293031public class Test &#123; private int i &#x3D; 0; public int increamentAndGet() &#123; System.out.println(&quot;当前余票&quot; + (100 - i)); synchronized (this) &#123; System.out.println(&quot;当前真实的余票&quot; + (100 - i)); i++; return i; &#125; &#125; public void thread(Test code) &#123; while (true) &#123; System.out.println(&quot;用户&quot; + Thread.currentThread().getName() + &quot;买了第&quot; + code.increamentAndGet() + &quot;张票&quot;); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; Test code &#x3D; new Test(); ExecutorService executorService &#x3D; Executors.newCachedThreadPool(); executorService.execute(() -&gt; code.thread(code)); executorService.execute(() -&gt; code.thread(code)); executorService.execute(() -&gt; code.thread(code)); &#125;&#125; 2.单例模式 使用场景： 数据库连接池的设计一般也是采用单例模式 多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。 Windows的Task Manager（任务管理器）就是很典型的单例模式（这个很熟悉吧），想想看，是不是呢，你能打开两个windows task manager吗？ 不信你自己试试看哦~ Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。 实现方式： 饿汉式：非懒加载，线程安全。明确需要实例化的情况下使用1234567public class Singleton &#123; private Singleton ()&#123;&#125; private static Singleton instance &#x3D; new Singleton(); public static Singleton getInstance() &#123; return instance; &#125;&#125; 双重校验锁：懒加载，线程安全。采用双锁机制，安全且在多线程情况下能保持高性能。1234567891011121314 public class Singleton &#123; private Singleton ()&#123;&#125; private volatile static Singleton singleton; public static Singleton getSingleton() &#123; if (singleton &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;第一重 synchronized (Singleton.class) &#123; if (singleton &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;第二重 singleton &#x3D; new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 静态内部类：懒加载，线程安全。明确需要懒加载或者实例化特别耗内存的时候使用。123456789 public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE &#x3D; new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125;&#125; 3. 线程池 1. 线程池介绍： 执行一个异步任务我们可能只是如下new Thread： 12345678public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;).start();&#125; jdk8之后可以用lambda 123public static void main(String[] args) &#123; new Thread(() -&gt; System.out.println(Thread.currentThread().getName())).start();&#125; 但是阿里规范不提尝使用Executors创建线程池 2. 自定义线程池： CPU密集型：操作内存处理的业务，一般线程数设置为：CPU核数 + 1 或者 CPU核数*2。核数为4的话，一般设置 5 或 8 IO密集型：文件操作，网络操作，数据库操作，一般线程设置为：cpu核数 / (1-0.9)，核数为4的话，一般设置 40 12自定义线程池构造方法ExecutorService pool1 &#x3D; new ThreadPoolExecutor(CPUCoreCount * 4, CPUCoreCount * 8, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(), new ThreadPoolExecutor.DiscardPolicy()); 3. 参数解释： 1、核心数线程池维护线程的最少数量，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。 2、最大数线程池维护线程的最大数量，它表示在线程池中最多能创建多少个线程；这个参数是跟后面的阻塞队列联系紧密的；只有当阻塞队列满了，如果还有任务添加到线程池的话，会尝试new 一个Thread的进行救急处理，立马执行对应的runnable任务；如果继续添加任务到线程池，且线程池中的线程数已经达到了maximumPoolSize，那么线程就会就会执行reject操作。 3、存活时间线程池维护线程所允许的空闲时间，表示线程没有任务执行时最多保持多久时间会终止；默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用；即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法并设置了参数为true，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的阻塞队列大小为0；（这部分通过查看ThreadPoolExecutor的源码分析–getTask()部分） 4、时间单位线程池维护线程所允许的空闲时间的单位，参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性（时间单位）。 5、缓冲队列线程池所使用的缓冲队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择ArrayBlockingQueue;LinkedBlockingQueue;SynchronousQueue;ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。 6、决绝策略ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。（默认handle）ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。 4. 执行流程：当一个任务通过execute(Runnable)方法欲添加到线程池时： 1、如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。 2、如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。 3、如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。 4、如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，则会使用handler处理被拒绝的任务。 5、当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样以来，线程池可以动态的调整池中的线程数 参考：https://juejin.im/post/5b25b3d0f265da597d0a9803#heading-17 5. 自定义线程名称：还是遭受到阿里爸爸的毒打，来吧继续，选中黄色提示按2次 ctrl + F1 先看看阿里爸爸的提示：可以按照这个写，也可以自定义线程工厂来拓展： 123456789101112131415161718192021222324252627&#x2F;&#x2F; 命名线程工厂 static class NamedThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber &#x3D; new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber &#x3D; new AtomicInteger(1); private final String namePrefix; NamedThreadFactory(String name) &#123; SecurityManager s &#x3D; System.getSecurityManager(); group &#x3D; (s !&#x3D; null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); if (null &#x3D;&#x3D; name || name.isEmpty()) &#123; name &#x3D; &quot;pool&quot;; &#125; namePrefix &#x3D; name + &quot;-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;; &#125; public Thread newThread(Runnable r) &#123; Thread t &#x3D; new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() !&#x3D; Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125; &#125; 12static ThreadPoolExecutor executorOne &#x3D; new ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;(), new NamedThreadFactory(&quot;Test-Pool&quot;));","categories":[],"tags":[{"name":"thread","slug":"thread","permalink":"pangxue.vip/tags/thread/"}]},{"title":"springcloud相关","slug":"springcloud相关","date":"2020-05-07T02:37:39.000Z","updated":"2020-05-07T09:26:04.152Z","comments":true,"path":"2020/05/07/aboutspringcloud/","link":"","permalink":"pangxue.vip/2020/05/07/aboutspringcloud/","excerpt":"","text":"1.Feign相关 404：检查RequestMapping路径是否正确 Request method ‘POST’ not supported： 参数是对象时候需要注意： 参数需要实现序列化 并且需要使用PostMapping,同样的控制层也需要是PostMapping 如果对象里面又包含对象，或者list，数组等,需要加@RequestBody把数据绑定到bean上 @RequestBody注解常用来处理content-type不是默认的application/x-www-form-urlcoded编码的内容，比如说：application/json类型。 feign远程调用，使用get方式： 不能使用对象传递参数。 在所有参数前加上@RequestParam注解，或者通过@PathVariable获取。 指明为GET方式 feign远程调用，使用post方式： 有且只有一个参数前为@RequestBody或什么也没有 如果有多个参数，那么其余参数前必须有@RequestParam 如果参数前什么也不写，那么默认是由@RequestBody指明的,这样不满足get请求，只能是post传递","categories":[],"tags":[{"name":"springcloud","slug":"springcloud","permalink":"pangxue.vip/tags/springcloud/"}]},{"title":"数据重复校验","slug":"数据重复校验","date":"2020-04-29T06:01:10.000Z","updated":"2020-04-29T10:41:07.118Z","comments":true,"path":"2020/04/29/check-data-repeat/","link":"","permalink":"pangxue.vip/2020/04/29/check-data-repeat/","excerpt":"","text":"1.利用aop实现。 注意：如果在微服务中想做成公用模块，那么可以新建个专门的工具模块来存放这些功能，然后不要生成web项目，通过spring 的工厂引入bean 配置文件装配bean： 12345678@Configuration@AllArgsConstructorpublic class ToolAutoConfiguration &#123; @Bean public CheckAspect checkAspect() &#123; return new CheckAspect(); &#125;&#125; spring.factories配置代码 12org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\\ com.xxx.xxx.common.tool.ToolAutoConfiguration 切片实现代码： *1.通过注解实现（控制层加注解，再进入请求方法之前就能执行，aop拦截注解，取出注解定义好的bean） * 2.通过切点实现 （直接切service服务） 完整切面逻辑代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Slf4j@Aspect@AllArgsConstructorpublic class CheckAspect &#123; &#x2F;** * @param: [joinPoint, checkRepeat] * @return: void * @description : aop 自定义注解实现校验（在进入方法前就可以判断，推荐） **&#x2F; @Before(value &#x3D; &quot;@annotation(checkRepeatValidator)&quot;) public void checkRepeat(JoinPoint joinPoint, CheckRepeatValidator checkRepeatValidator) throws IllegalAccessException, InstantiationException &#123; IService iService &#x3D; (IService)SpringContextUtil.getBean(checkRepeatValidator.service()); Object entityObj &#x3D; checkRepeatValidator.entity().newInstance(); Object vo &#x3D; joinPoint.getArgs()[0]; BeanUtils.copyProperties(vo, entityObj); check(iService, entityObj); &#125; &#x2F;** * @param: [joinPoint] * @return: void * @description : aop 切点实现（只能在调用保存方法后才出发，与上述注解实现选其一） **&#x2F; @Before(value &#x3D; &quot;execution(* com.bluecloud.kebest.*.service.*.save*(..)) || execution(* com.bluecloud.kebest.*.service.*.update*(..)) &quot;) public void checkRepeat(JoinPoint joinPoint) throws IllegalAccessException &#123; Object entityObj &#x3D; joinPoint.getArgs()[0]; ServiceImpl iService &#x3D; (ServiceImpl) joinPoint.getTarget(); if (entityObj.getClass().isAnnotationPresent(CheckRepeat.class)) &#123; check(iService, entityObj); &#125; &#125; private void check(IService iService, Object entityObj) throws IllegalAccessException &#123; QueryWrapper queryWrapper &#x3D; new QueryWrapper(); Field[] declaredFields &#x3D; entityObj.getClass().getDeclaredFields(); StringBuilder builder &#x3D; new StringBuilder(); Object id &#x3D; null; for (Field field : declaredFields) &#123; CheckRepeat annotation &#x3D; field.getAnnotation(CheckRepeat.class); if (annotation !&#x3D; null) &#123; field.setAccessible(true); String fieldName &#x3D; field.getName(); Object fieldVal &#x3D; field.get(entityObj); ApiModelProperty info &#x3D; field.getAnnotation(ApiModelProperty.class); String fieldChineseName &#x3D; info.value(); CheckTypeEnum checkTypeEnum &#x3D; annotation.checkType(); if (checkTypeEnum &#x3D;&#x3D; CheckTypeEnum.eachCheck) &#123; queryWrapper.or(); &#125; queryWrapper.eq(CamelConvert.camel2Underline(fieldName), fieldVal); builder.append(&quot;,&quot; + fieldChineseName); &#125; if (field.getName().equals(&quot;id&quot;)) &#123; field.setAccessible(true); id &#x3D; field.get(entityObj); &#125; &#125; builder.delete(0, 1); int count &#x3D; iService.count(queryWrapper); &#x2F;&#x2F;通过id是否为null来判断是新增还是编辑，编辑的情况要排除自身 if (id !&#x3D; null) &#123; count--; &#125; if (count &gt; 0) &#123; throw new RuntimeException(builder.toString() + &quot;已被占用,请重新填写&quot;); &#125; &#125;&#125; 2.使用validation校验 控制层入参开启 @validated 注解 *由于控制层校验的是vo，需指明校验的entity * *entity继承 mybatis-plus 的 Model * *entity 设置校验类型（图为联合校验，2个字段保证唯一） * *注解上指明校验的类 * *校验的类实现 ConstraintValidator并调用工具类做业务处理 * **详细代码地址 **","categories":[],"tags":[{"name":"aop,validation","slug":"aop-validation","permalink":"pangxue.vip/tags/aop-validation/"}]},{"title":"树形结构","slug":"高性能树形结构","date":"2020-04-27T09:41:11.000Z","updated":"2020-04-27T09:43:47.421Z","comments":true,"path":"2020/04/27/tree/","link":"","permalink":"pangxue.vip/2020/04/27/tree/","excerpt":"","text":"利用map特性，但是需要对父级id排序12345678910111213141516public &lt;T extends TreeNode&gt; List&lt;T&gt; buildAccordMap(List&lt;T&gt; treeNodes, Object root) &#123; MapT&gt; map &#x3D; new HashMap&lt;&gt;(); MapT&gt; collect &#x3D; treeNodes.stream().collect(Collectors.toMap(T::getId, obj -&gt; obj)); treeNodes.sort(Comparator.comparing(T::getParentId)); treeNodes.forEach(n -&gt; &#123; if (root.equals(n.getParentId())) &#123; map.put(n.getId(), n); &#125; else &#123; T child &#x3D; collect.get(n.getParentId()); child.getChildren().add(n); &#125; &#125;); List&lt;T&gt; newList &#x3D; new ArrayList&lt;&gt;(); map.forEach((k, v) -&gt; newList.add(v)); return newList;&#125; 2层for循环1234567891011121314151617public &lt;T extends TreeNode&gt; List&lt;T&gt; build(List&lt;T&gt; treeNodes, Object root) &#123; List&lt;T&gt; trees &#x3D; new ArrayList&lt;&gt;(); for (T treeNode : treeNodes) &#123; if (root.equals(treeNode.getParentId())) &#123; trees.add(treeNode); &#125; for (T it : treeNodes) &#123; if (it.getParentId() &#x3D;&#x3D; treeNode.getId()) &#123; if (treeNode.getChildren() &#x3D;&#x3D; null) &#123; treeNode.setChildren(new ArrayList&lt;&gt;()); &#125; treeNode.add(it); &#125; &#125; &#125; return trees;&#125;","categories":[],"tags":[{"name":"树形结构","slug":"树形结构","permalink":"pangxue.vip/tags/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/"}]},{"title":"gitlab相关","slug":"gitlab相关","date":"2020-04-27T06:48:48.000Z","updated":"2020-04-29T06:09:43.392Z","comments":true,"path":"2020/04/27/gitlab/","link":"","permalink":"pangxue.vip/2020/04/27/gitlab/","excerpt":"","text":"1. 强制回退版本12git reset --hard fb479960c0cec5549463ae123d70bdd72ccf6be7git push -f origin master 2. 本地新项目上传到git已有项目中123456git initgit add .git commit -m &#39;first commit&#39;git remote add origin 你的远程库地址git pull --rebase origin mastergit push -u origin master","categories":[],"tags":[{"name":"gitlab","slug":"gitlab","permalink":"pangxue.vip/tags/gitlab/"}]},{"title":"EasyExcel踩坑","slug":"EasyExcel","date":"2020-04-24T07:40:45.000Z","updated":"2020-04-24T08:38:54.890Z","comments":true,"path":"2020/04/24/EasyExcel/","link":"","permalink":"pangxue.vip/2020/04/24/EasyExcel/","excerpt":"","text":"1. Could not initialize class com.alibaba.excel.write.ExcelBuilderImpl 解决办法：跟poi依赖冲突，easyexcel底层使用poi了 2. Can not find ‘Converter’ support class LocalDateTime. 解决办法：LocalDateTime 属于jdk8.所以暂时不支持。这个需要自己自定义转换器。 1：注解 123456789101112@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface LocalDateTimeFormat &#123; &#x2F;** * 指定LocalDateTime转化的日期格式 * 例如 : &quot;yyyy-MM-dd HH:mm:ss&quot;,导入导出都会将LocalDateTime转化为对应格式字符串 * * @return 日期格式 *&#x2F; String value();&#125; 2：转化器 12345678910111213141516171819202122232425262728293031323334353637383940414243public class LocalDateTimeExcelConverter implements Converter &#123;&#x2F;** * 不使用&#123;@code @LocalDateTimeFormat&#125;注解指定日期格式时,默认会使用该格式. **&#x2F; private static final String DEFAULT_PATTERN &#x3D; &quot;yyyy&#x2F;MM&#x2F;dd HH:mm:ss&quot;; @Override public Class supportJavaTypeKey() &#123; return LocalDateTime.class; &#125; @Override public CellDataTypeEnum supportExcelTypeKey() &#123; return CellDataTypeEnum.STRING; &#125;&#x2F;** * 这里读的时候会调用 * @param cellData excel数据 (NotNull) * @param contentProperty excel属性 (Nullable) * @param globalConfiguration 全局配置 (NotNull) * @return 读取到内存中的数据 * *&#x2F; @Override public LocalDateTime convertToJavaData(CellData cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) &#123; LocalDateTimeFormat annotation &#x3D; contentProperty.getField().getAnnotation(LocalDateTimeFormat.class); return LocalDateTime.parse(cellData.getStringValue(), DateTimeFormatter.ofPattern(Objects.nonNull(annotation) ? annotation.value() : DEFAULT_PATTERN)); &#125;&#x2F;** * 写的时候会调用 * @param value java value (NotNull) * @param contentProperty excel属性 (Nullable) * @param globalConfiguration 全局配置 (NotNull) * @return 写出到excel文件的数据 **&#x2F; @Override public CellData convertToExcelData(LocalDateTime value, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) &#123; LocalDateTimeFormat annotation &#x3D; contentProperty.getField().getAnnotation(LocalDateTimeFormat.class); return new CellData(value.format(DateTimeFormatter.ofPattern(Objects.nonNull(annotation) ? annotation.value() : DEFAULT_PATTERN))); &#125; 3：工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Slf4jpublic class EasyExcelUtil &#123; private static OutputStream getOutputStream(String fileName) throws IOException &#123; HttpServletResponse response &#x3D; ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getResponse(); if (response !&#x3D; null) &#123; fileName &#x3D; URLEncoder.encode(fileName, &quot;UTF-8&quot;); response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename&#x3D;&quot; + fileName + &quot;.xls&quot;);&#x2F;&#x2F; 指定下载的文件名 response.setContentType(&quot;application&#x2F;vnd.ms-excel&quot;); return response.getOutputStream(); &#125; return null; &#125; &#x2F;** * @param fileName 文件名称 * @param sheetName 表格名称 * @param list 查询数据list * @param list泛型 * @description web直接下载报表util，样式这里能设置一部门，列宽列高都在泛型类里设置 *&#x2F; public static &lt;T&gt; void webDownloadExcel(String fileName, String sheetName, List&lt;T&gt; list) &#123; try &#123; OutputStream out &#x3D; getOutputStream(fileName); &#x2F;&#x2F; 头的策略 WriteCellStyle headWriteCellStyle &#x3D; new WriteCellStyle(); &#x2F;&#x2F; 背景设置为红色 &#x2F;&#x2F;headWriteCellStyle.setFillForegroundColor(IndexedColors.RED.getIndex()); WriteFont headWriteFont &#x3D; new WriteFont(); headWriteFont.setFontHeightInPoints((short) 12); headWriteCellStyle.setWriteFont(headWriteFont); &#x2F;&#x2F; 内容的策略 WriteCellStyle contentWriteCellStyle &#x3D; new WriteCellStyle(); &#x2F;&#x2F; 这里需要指定 FillPatternType 为FillPatternType.SOLID_FOREGROUND 不然无法显示背景颜色.头默认了 FillPatternType所以可以不指定 &#x2F;&#x2F;contentWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND); &#x2F;&#x2F; 背景绿色 &#x2F;&#x2F;contentWriteCellStyle.setFillForegroundColor(IndexedColors.GREEN.getIndex()); WriteFont contentWriteFont &#x3D; new WriteFont(); &#x2F;&#x2F; 字体大小 contentWriteFont.setFontHeightInPoints((short) 11); contentWriteCellStyle.setWriteFont(contentWriteFont); &#x2F;&#x2F; 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现 HorizontalCellStyleStrategy horizontalCellStyleStrategy &#x3D; new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle); if (list !&#x3D; null &amp;&amp; list.size() &gt; 0) &#123; EasyExcel.write(out, list.get(0).getClass()).registerWriteHandler(horizontalCellStyleStrategy).sheet(sheetName).doWrite(list); &#125; &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); &#125; &#125;&#125; 4：使用方式： 12@ExcelProperty(value &#x3D; &quot;创建时间&quot;, converter &#x3D; LocalDateTimeExcelConverter.class)@LocalDateTimeFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)","categories":[],"tags":[{"name":"EasyExcel","slug":"EasyExcel","permalink":"pangxue.vip/tags/EasyExcel/"}]},{"title":"aop校验数据重复","slug":"aop校验数据重复","date":"2020-04-22T10:08:07.000Z","updated":"2021-03-07T07:36:18.370Z","comments":true,"path":"2020/04/22/aopCheckRepeat/","link":"","permalink":"pangxue.vip/2020/04/22/aopCheckRepeat/","excerpt":"","text":"1.切的是service层，save或者update开头的实现类。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;import com.bluecloud.kebest.common.core.anno.CheckRepeatAnno;import com.bluecloud.kebest.common.core.util.CamelConvert;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;import java.lang.reflect.Field;@Aspect@Componentpublic class CheckAspect &#123; @Pointcut(&quot;execution(* com.bluecloud.kebest.storage.service.*.save*(..)) || execution(* com.bluecloud.kebest.storage.service.*.update*(..)) &quot;) private void checkRepeatPointCut() &#123; &#125; @Before(value &#x3D; &quot;checkRepeatPointCut()&quot;) public void checkRepeat(JoinPoint joinPoint) throws IllegalAccessException &#123; Object param &#x3D; joinPoint.getArgs()[0]; Object target &#x3D; joinPoint.getTarget(); Class paramClass &#x3D; param.getClass(); ServiceImpl iService &#x3D; (ServiceImpl) target; QueryWrapper queryWrapper &#x3D; new QueryWrapper&lt;&gt;(); Field[] declaredFields &#x3D; paramClass.getDeclaredFields(); StringBuilder builder &#x3D; new StringBuilder(); boolean flag &#x3D; false; for (Field field : declaredFields) &#123; CheckRepeatAnno annotation &#x3D; field.getAnnotation(CheckRepeatAnno.class); if (annotation !&#x3D; null) &#123; flag &#x3D; true; field.setAccessible(true); String fieldName &#x3D; field.getName(); Object fieldVal &#x3D; field.get(param); queryWrapper.eq(CamelConvert.camel2Underline(fieldName), fieldVal); builder.append(fieldName + &quot; &quot;); &#125; &#125; if (flag) &#123; int count &#x3D; iService.count(queryWrapper); if (count &gt; 0) &#123; throw new RuntimeException(builder.toString() + &quot;数据重复&quot;); &#125; &#125; &#125;&#125;","categories":[],"tags":[{"name":"aop","slug":"aop","permalink":"pangxue.vip/tags/aop/"}]},{"title":"lambda常用写法","slug":"lambda常用写法","date":"2020-04-20T02:47:30.000Z","updated":"2021-04-10T17:43:10.651Z","comments":true,"path":"2020/04/20/aboutlambda/","link":"","permalink":"pangxue.vip/2020/04/20/aboutlambda/","excerpt":"","text":"1.lambda简介 Lambda 表达式，也可称为闭包,包含以下特性： 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。 作用域：只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量 2.排序 数组排序：Arrays.sort(players, (String s1, String s2) -&gt; (s1.compareTo(s2))); 集合排序正序：depListso.sort(Comparator.comparing(AuthorizeTree::getSort)); 集合排序倒序：depListso.sort(Comparator.comparing(AuthorizeTree::getSort).reversed()); 3.流式 1.过滤（filter）：records.stream().filter(n -&gt; (n.getId() &gt; 1 &amp;&amp; n.getStatus() .length()==2)).collect(Collectors.toList()); 2.匹配（allMatch）： 123456boolean b &#x3D; records.stream().allMatch(n -&gt; n.getId() &gt; 1)List&lt;String&gt; strs &#x3D; Arrays.asList(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;); boolean aa &#x3D; strs.stream().anyMatch(str -&gt; str.equals(&quot;a&quot;));&#x2F;&#x2F; TRUE boolean bb &#x3D; strs.stream().allMatch(str -&gt; str.equals(&quot;a&quot;));&#x2F;&#x2F; FALSE boolean cc &#x3D; strs.stream().noneMatch(str -&gt; str.equals(&quot;a&quot;));&#x2F;&#x2F; FALSE long count &#x3D; strs.stream().filter(str -&gt; str.equals(&quot;a&quot;)).count();&#x2F;&#x2F; 4 3.转换（map）records.stream().map(LocationVo::getCode).collect(Collectors.toList()) 4.运算（reduce）String s = records.stream().map(LocationVo::getCode).reduce((x, y) -&gt; x + y).get(); 5.最大最小（max，min）LocalDate maxDate = dates.stream().max( Comparator.comparing( LocalDate::toEpochDay ) ).get(); 6.收集器（collect）data.stream().collect(Collectors.toMap(UserVO::getUserId,n-&gt;n, (k1, k2) -&gt; k1)) 7.list转map（）data.stream().collect(Collectors.toMap(UserVO::getUserId,n-&gt;n, (k1, k2) -&gt; k1)) toMap第一个参数：key，第二个参数：value，第三个参数：如果重复取第一个key 8.list转map（分组）Map&lt;String, List&lt;SysDictItem&gt;&gt; collect = list.stream().collect(Collectors.groupingBy(SysDictItem::getType)); 9.list转map（进阶） 123456789101112List&lt;PartsInStorageDetailVo&gt; list&#x3D;new ArrayList&lt;&gt;();Map&lt;Integer, List&lt;Integer&gt;&gt; partIdsMap &#x3D; list.stream().collect(Collectors.toMap( PartsInStorageDetailVo::getInStorageId, val -&gt; &#123; List&lt;Integer&gt; ids &#x3D; new ArrayList&lt;&gt;(); ids.add(val.getPartsId()); return ids; &#125;, (k1, k2) -&gt; &#123; k1.addAll(k2); return k1.stream().distinct().collect(Collectors.toList()); &#125;));&#x2F;&#x2F;针对对象的其中两个属性进行分组，分组后如果key重复那么并集 10. 两个list求交集，差集 123456789if (needEnums !&#x3D; null &amp;&amp; !needEnums.isEmpty()) &#123;&#x2F;&#x2F;交集 return needEnums.stream().filter(allFieldEnums::contains).collect(Collectors.toList());&#125; else if (notNeedEnums !&#x3D; null &amp;&amp; !notNeedEnums.isEmpty()) &#123;&#x2F;&#x2F;差集 return allFieldEnums.stream().filter(n -&gt; !notNeedEnums.contains(n)).collect(Collectors.toList());&#125; else &#123; return allFieldEnums;&#125; list对象某个字段拼接起来1String cutterCodes &#x3D; cutterList.stream().map(PartsMachiningCutterDetailVo::getCutterCode).collect(Collectors.joining(&quot;,&quot;)); list对象某个属性去重1checkFinalVoList &#x3D; checkFinalVoList.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(CheckFinalVo::getOrderId))), ArrayList::new));","categories":[],"tags":[{"name":"lambda","slug":"lambda","permalink":"pangxue.vip/tags/lambda/"}]},{"title":"idea中mybatis常见设置","slug":"idea中mybatis常见设置","date":"2020-04-17T03:02:29.000Z","updated":"2020-04-17T03:59:40.239Z","comments":true,"path":"2020/04/17/idea-mybatis-general-setting/","link":"","permalink":"pangxue.vip/2020/04/17/idea-mybatis-general-setting/","excerpt":"","text":"1.推荐使用MyBatisCodeHelperPro插件，但是使用时代码飘红，Result type is xxx, Not match for List&lt;xxx&gt;“","categories":[],"tags":[{"name":"ideaSetting","slug":"ideaSetting","permalink":"pangxue.vip/tags/ideaSetting/"}]},{"title":"java新建父子项目","slug":"java新建父子项目","date":"2020-04-14T07:56:16.000Z","updated":"2020-04-14T08:04:12.623Z","comments":true,"path":"2020/04/14/module/","link":"","permalink":"pangxue.vip/2020/04/14/module/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"idea插件","slug":"lombok相关","date":"2020-04-14T07:41:56.000Z","updated":"2020-04-15T06:15:44.546Z","comments":true,"path":"2020/04/14/aboutlombok/","link":"","permalink":"pangxue.vip/2020/04/14/aboutlombok/","excerpt":"","text":"首先，用到的几个注解： 1.Lombok@Data 使用这个注解，就不用再去手写Getter,Setter,equals,canEqual,hasCode,toString等方法了，注解后在编译时会自动加进去。 @AllArgsConstructor 使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数，在controller里或者无需使用@Resource注解注入service @NoArgsConstructor 使用后创建一个无参构造函数 2. Free Mybatis plugin","categories":[],"tags":[{"name":"idea插件","slug":"idea插件","permalink":"pangxue.vip/tags/idea%E6%8F%92%E4%BB%B6/"}]},{"title":"Mysql优化心得","slug":"Mysql优化心得","date":"2020-04-06T03:12:11.000Z","updated":"2020-04-06T10:13:13.630Z","comments":true,"path":"2020/04/06/sqlOptimization/","link":"","permalink":"pangxue.vip/2020/04/06/sqlOptimization/","excerpt":"","text":"1. 建表基础向 1. 字段精度尽量精确，能用int就不用varchar，能用tinyint就不用int 2. null用数字代替 3. 枚举类可用数字代替 2. 索引 1. 索引不宜多，常用的where，order by字段索引 2. 避免索引上的null的判断，比较 3. varchar比较大的可以试试前缀索引 4. 联合索引和单索引重叠时，可以删除单索引，注意顺序 3. sql向 1. 不要在sql中运算，运算放在程序里 2. 小数据in是可以走索引的 3. 存储过程，触发器，时间尽量在程序中实现 4. join on的字段类型要保持一致 4. 简单水平分区 1. 数据分散，对大表数据最简单的优化方案，通常基于时间分区（Range分区），并且开始设置每天，月自动执行分区。查询时加上时间范围很快。 2. 如果某个字段有特殊的意义会导致经常访问，那么可以按照这个逻辑把这个数据放到单独的分区表中，或者缓存到缓存中 5. 垂直分库 把大表常用字段和不常用字段垂直拆开，分为两个表，或者多个表。只能使行数据变小但是无法解决单表数据量过大的问题，而且要维护主键，维护代码","categories":[{"name":"MYSQL","slug":"MYSQL","permalink":"pangxue.vip/categories/MYSQL/"}],"tags":[{"name":"sql优化","slug":"sql优化","permalink":"pangxue.vip/tags/sql%E4%BC%98%E5%8C%96/"}]},{"title":"springboot+security+JWT","slug":"springboot+security+JWT","date":"2020-03-28T02:04:31.000Z","updated":"2020-04-05T06:51:07.515Z","comments":true,"path":"2020/03/28/springboot+security+JWT/","link":"","permalink":"pangxue.vip/2020/03/28/springboot+security+JWT/","excerpt":"","text":"1. 简介 security是企业级安全框架，可用于用户认证,实现前后分离权限注解，通过JWT登录认证 2. 教程 教程： https://mp.weixin.qq.com/s/v6qUncrHI09S2s3GroTe7w 3. 配置jwt jwt相关属性可配置在配置文件中 3. jwt配置类的映射model 需要注意：并且要注意下propertySource注解的 factory = YamlPropertySourceFactory.class,这个是专门为了yml配置文件注入 ４. 单点登陆： 实质上就是刷新token，并且保证之前的token失效，如果使用redis存储token就又变得有状态了，违反了设计初衷，放在数据库中每次都要查询，浪费资源。目前好香米有什么好的解决办法","categories":[{"name":"java","slug":"java","permalink":"pangxue.vip/categories/java/"}],"tags":[{"name":"springboot","slug":"springboot","permalink":"pangxue.vip/tags/springboot/"},{"name":"security","slug":"security","permalink":"pangxue.vip/tags/security/"},{"name":"JWT","slug":"JWT","permalink":"pangxue.vip/tags/JWT/"}]},{"title":"swagger踩坑","slug":"swagger踩坑","date":"2020-03-27T14:32:44.000Z","updated":"2020-04-02T14:06:41.119Z","comments":true,"path":"2020/03/27/java-swagger/","link":"","permalink":"pangxue.vip/2020/03/27/java-swagger/","excerpt":"","text":"1. 前情提要 请按照以下地址配置： https://blog.csdn.net/weixin_33690963/article/details/92055964 2. 启动失败 项目启动，注册bean失败，打包失败，由于项目使用了mp2，发现是model映射字段出问题了，开启驼峰自动映射之后一定要注意字段名字问题 3. swagger首页空白 swagger访问页面空白，发开F12,发现swagger-ui.html页面404，由于项目使用了security，说明被拦截了，打开JWT配置文件添加以下设置 3. 页面404 参考：https://blog.csdn.net/ljm_csdn/article/details/87615670，一定是管理资源的 WebMvcConfiguration 在其他配置类里被占用了，我的事在 json 配置类里占用的","categories":[{"name":"java","slug":"java","permalink":"pangxue.vip/categories/java/"}],"tags":[{"name":"swagger","slug":"swagger","permalink":"pangxue.vip/tags/swagger/"}]},{"title":"Hexo工具（三）","slug":"Hexo工具（三）","date":"2020-03-27T00:59:16.000Z","updated":"2020-03-27T02:36:25.522Z","comments":true,"path":"2020/03/27/HexoTools/","link":"","permalink":"pangxue.vip/2020/03/27/HexoTools/","excerpt":"","text":"1. 为什么使用HexoEditor? 1.这个软件有腾讯云的存储桶，也就是oss，配置好文件后一键上传图片很方便。 2.可以直接新建post，不用频繁的输入命令，只需定义新建post模板即可 3.一边写一边可以预览，样式不对了可以及时调整 2. 下载与安装 链接: https://pan.baidu.com/s/1nmvkEE4kKeQ-9wIbX3hiGA 提取码: r6yx 为什么不用最新版？最新版新建post没有标头 3. 使用 创建腾讯云密钥https://console.cloud.tencent.com/cam/capi点击新建密钥即可 默认资源库：存放本地图片的地方，自定义 access key：腾讯云的API密钥管理的SecretId secret key：腾讯云的API密钥管理的SecretKey 上述填对之后其他存储空间，域名会自动填写 4. 上传图片右键编辑页面，点击 上传 腾讯云,会把全部文件上传到腾讯云","categories":[{"name":"教程","slug":"教程","permalink":"pangxue.vip/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"pangxue.vip/tags/hexo/"},{"name":"HexoEditor","slug":"HexoEditor","permalink":"pangxue.vip/tags/HexoEditor/"},{"name":"ide","slug":"ide","permalink":"pangxue.vip/tags/ide/"}]},{"title":"Hexo进阶（二）","slug":"Hexo进阶（二）","date":"2020-03-26T01:13:31.000Z","updated":"2020-03-27T02:40:01.385Z","comments":true,"path":"2020/03/26/HexoAdvanced/","link":"","permalink":"pangxue.vip/2020/03/26/HexoAdvanced/","excerpt":"","text":"1.hexo各文件介绍 2.hexo主题推荐 个人使用pure，推荐next，fan，human等，主题挑选网站：主题pure下载以及安装 3.hexo主题配置 复制theme/pure/_source/文件夹到blog path/source/ 目录下以便安装全部功能hexo全局配置在根目录_config.yml里theme: pure,输入对应的主题名保存即可更换主题，每个主题的配置文件在根目录文件夹themes下，继续修改相关信息 4.配置评论功能 目前免服务器的有gitment（停止维护），gittalk（推荐） 1. 点我设置github授权地址操作演示：注册成功后记住 ClientID 和 ClientSecret，下一步用 2. 修改主题配置12345678comment: type: gitalk # 启用哪种评论系统 gitalk: # gitalk. https:&#x2F;&#x2F;gitalk.github.io&#x2F; owner: #必须. GitHub repository 所有者，可以是个人或者组织。 admin: #必须. GitHub repository 的所有者和合作者 (对这个 repository 有写权限的用户)。 repo: comment #必须. GitHub repository. ClientID: #必须. GitHub Application Client ID. ClientSecret: #必须. GitHub Application Client Secret. 3. 登陆github账户记录评论如果报错请自行百度，目前遇到 network error情况，为当前wifi问题 4. 更换正文字体大小 通过 F12 发现正文文字是用&lt;p&gt; ，然后找了下文件夹，最后定位到pure\\source\\css文件夹下style.css中，往下拉定位到&lt;p&gt;标签加这么一行保存重启hexo 5. 搜索出现bug 搜索文章正常说明搜索功能是好使的，但是搜索标签等就出现问题了，发现跳到https://yoursite.com/categories/%E6%95%99%E7%A8%8B/,说明配置里一定有这个网站，于是全局搜索yoursite发现根目录配置url，修改成自己博客地址即可 6. title是中地址栏转义问题 写博客的过程中出现过以下情况这样就很烦，看着也不规范，看了下结构是发现用的 .md 文件的 title 命名的,像这种模版化的规则一般都有配置的，于是着了下hexo配置文件，发现这么个东西permalink: :year/:month/:day/:title/,发现正好对上了，百度了下这个东西叫永久链接的配置，那这样就好办了，想到这个title只是一个定位标示，如果把定位标示变成数字或者字母不就好了，于是scaffolds/post.md里面修改默认新建post的模版，添加个字段alias，然后配置里面permalink: :year/:month/:day/:alias/，打完收工","categories":[{"name":"教程","slug":"教程","permalink":"pangxue.vip/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"pangxue.vip/tags/hexo/"},{"name":"主题","slug":"主题","permalink":"pangxue.vip/tags/%E4%B8%BB%E9%A2%98/"}]},{"title":"Hexo安装（一）","slug":"Hexo安装（一）","date":"2020-03-25T13:51:07.000Z","updated":"2020-03-27T02:39:41.616Z","comments":true,"path":"2020/03/25/HexoInstallation/","link":"","permalink":"pangxue.vip/2020/03/25/HexoInstallation/","excerpt":"","text":"1. 安装hexo 详细安装过程可参考安装教程 1.1 安装 git windows下载地址：https://git-scm.com/download/win双击下载好的exe文件，一路next就好啦git version 查看版本 1.2 安装 nodejs 下载地址：下载地址 。双击打开安装，也是一路next，不过在Custom Setup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了，装完在按 win + r 快捷键调出运行，然后输入cmd确定，在cmd中输入path可以看到你的node是否配置在里面（环境变量） 自定义插件安装位置可参考 在D:\\work\\nodejs里新建2个文件夹node_global及node_cache,接下来打开命令行12npm config set prefix &quot;D:\\work\\nodejs\\npm_global&quot;npm config set cache &quot;D:\\work\\nodejs\\npm_cache&quot; 打开系统变量，新建NODE_PATHD:\\work\\nodejs\\npm_global\\node_modules 编辑用户变量中的path，C: \\Users\\px\\App Data\\Roaming\\npm替换成D:\\work\\nodejs\\npm_global 1.3 配置npm 在想要安装的目标文件夹下打开GitBash 1234npm config set registry &quot;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;&quot;npm config set electron_mirror &quot;https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;electron&#x2F;&quot;npm i -g hexohexo init 1.4 搭建gitHub项目 自行搭建ssh免密码push git项目，创建一个repo，名称为yourname.github.io, 其中yourname是你的github名称，生成项目的最终地址是https://github.com/yourname/yourname.github.io.git,hexo的外网访问环境是https://yourname.github.io/ 1.5 将hexo上传到gitHub 用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)： deploy: type: git repo: git@github.com:YourName/YourbName.github.io.git branch: master npm install hexo-deployer-git --save hexo clean hexo g hexo d如果出现以下错误：那么说明头部格式错误，请检查头部格式： 1.6 绑定个人域名 访问腾讯域名管理网站（域名自行购买）https://console.cloud.tencent.com/domain点 操作-&gt;解析-&gt;添加记录其中最重要的是ip解析，打开cmd，输入 ping yourname.github.io，把返回的ip地址填入，然后保存。如果出现４０４是因为：项目操作变化需要修改映射的ip地址，可能是github项目被修改了，或者github出现缓存了，刷新页面或者重新部署等等","categories":[{"name":"教程","slug":"教程","permalink":"pangxue.vip/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"pangxue.vip/tags/hexo/"},{"name":"教程","slug":"教程","permalink":"pangxue.vip/tags/%E6%95%99%E7%A8%8B/"}]}],"categories":[{"name":"mysql","slug":"mysql","permalink":"pangxue.vip/categories/mysql/"},{"name":"MYSQL","slug":"MYSQL","permalink":"pangxue.vip/categories/MYSQL/"},{"name":"java","slug":"java","permalink":"pangxue.vip/categories/java/"},{"name":"教程","slug":"教程","permalink":"pangxue.vip/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"pangxue.vip/tags/mysql/"},{"name":"MyBatisCodeHelper","slug":"MyBatisCodeHelper","permalink":"pangxue.vip/tags/MyBatisCodeHelper/"},{"name":"idea","slug":"idea","permalink":"pangxue.vip/tags/idea/"},{"name":"thread","slug":"thread","permalink":"pangxue.vip/tags/thread/"},{"name":"springcloud","slug":"springcloud","permalink":"pangxue.vip/tags/springcloud/"},{"name":"aop,validation","slug":"aop-validation","permalink":"pangxue.vip/tags/aop-validation/"},{"name":"树形结构","slug":"树形结构","permalink":"pangxue.vip/tags/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/"},{"name":"gitlab","slug":"gitlab","permalink":"pangxue.vip/tags/gitlab/"},{"name":"EasyExcel","slug":"EasyExcel","permalink":"pangxue.vip/tags/EasyExcel/"},{"name":"aop","slug":"aop","permalink":"pangxue.vip/tags/aop/"},{"name":"lambda","slug":"lambda","permalink":"pangxue.vip/tags/lambda/"},{"name":"ideaSetting","slug":"ideaSetting","permalink":"pangxue.vip/tags/ideaSetting/"},{"name":"idea插件","slug":"idea插件","permalink":"pangxue.vip/tags/idea%E6%8F%92%E4%BB%B6/"},{"name":"sql优化","slug":"sql优化","permalink":"pangxue.vip/tags/sql%E4%BC%98%E5%8C%96/"},{"name":"springboot","slug":"springboot","permalink":"pangxue.vip/tags/springboot/"},{"name":"security","slug":"security","permalink":"pangxue.vip/tags/security/"},{"name":"JWT","slug":"JWT","permalink":"pangxue.vip/tags/JWT/"},{"name":"swagger","slug":"swagger","permalink":"pangxue.vip/tags/swagger/"},{"name":"hexo","slug":"hexo","permalink":"pangxue.vip/tags/hexo/"},{"name":"HexoEditor","slug":"HexoEditor","permalink":"pangxue.vip/tags/HexoEditor/"},{"name":"ide","slug":"ide","permalink":"pangxue.vip/tags/ide/"},{"name":"主题","slug":"主题","permalink":"pangxue.vip/tags/%E4%B8%BB%E9%A2%98/"},{"name":"教程","slug":"教程","permalink":"pangxue.vip/tags/%E6%95%99%E7%A8%8B/"}]}