<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>px-blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="pangxue.vip/"/>
  <updated>2021-04-10T17:36:54.354Z</updated>
  <id>pangxue.vip/</id>
  
  <author>
    <name>px</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java中的代理</title>
    <link href="pangxue.vip/2021/04/11/null/"/>
    <id>pangxue.vip/2021/04/11/null/</id>
    <published>2021-04-10T17:27:53.000Z</published>
    <updated>2021-04-10T17:36:54.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p><strong>动态代理技术就是用来产生一个对象的代理对象的</strong>。<br>　1、<strong>代理对象存在的价值主要用于拦截对真实业务对象的访问</strong>。<br>　2、<strong>代理对象应该具有和目标对象(真实业务对象)相同的方法</strong>。<br>　刘德华<strong>(真实业务对象)</strong>会唱歌，会跳舞，会拍戏，我们现在不能直接找他唱歌，跳舞，拍戏了，只能找他的代理人(<strong>代理对象</strong>)唱歌，跳舞，拍戏，一个人要想成为刘德华的代理人，那么他必须具有和刘德华一样的行为(会唱歌，会跳舞，会拍戏)，刘德华有什么方法，他(代理人)就要有什么方法，我们找刘德华的代理人唱歌，跳舞，拍戏，但是代理人不是真的懂得唱歌，跳舞，拍戏的，真正懂得唱歌，跳舞，拍戏的是刘德华，在现实中的例子就是我们要找刘德华唱歌，跳舞，拍戏，那么只能先找他的经纪人，交钱给他的经纪人，然后经纪人再让刘德华去唱歌，跳舞，拍戏。<br>这个现实中的例子和我们在开发中是一样的，我们在开发中之所以要产生一个对象的代理对象，主要用于拦截对真实业务对象的访问。那么代理对象应该具有什么方法呢？代理对象应该具有和目标对象相同的方法</p><h2 id="２．Java中的动态代理："><a href="#２．Java中的动态代理：" class="headerlink" title="２．Java中的动态代理："></a>２．Java中的动态代理：</h2><p>　　现在要生成某一个对象的代理对象，这个代理对象通常也要编写一个类来生成，所以首先要编写用于生成代理对象的类。在java中如何用程序去生成一个对象的代理对象呢，java在JDK1.5之后提供了一个<strong><code>java.lang.reflect.Proxy</code></strong>类，通过<strong><code>Proxy</code></strong>类提供的一个<strong><code>newProxyInstanc</code></strong>方法用来创建一个对象的代理对象，，这个方法总共有3个参数，<strong><code>ClassLoader loader</code></strong>用来指明生成代理对象使用哪个类装载器，<strong><code>Class[] interfaces</code></strong>用来指明生成哪个对象的代理对象，通过接口指定，<strong><code>InvocationHandler</code></strong> 用来指明产生的这个代理对象要做什么事情。所以我们只需要调用<strong><code>newProxyInstance</code></strong>方法就可以得到某一个对象的代理对象了。在java中规定，要想产生一个对象的代理对象，那么这个对象必须要有一个接口**</p><h2 id="3．实战-RabbitMq中的实战-："><a href="#3．实战-RabbitMq中的实战-：" class="headerlink" title="3．实战(RabbitMq中的实战)："></a>3．实战(RabbitMq中的实战)：</h2><ul><li>1.定义对象接口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface BaseConsumer &#123;</span><br><span class="line"> void consume(Message message, Channel channel) throws IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>2.定义被代理对象实现对象接口<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class PartsBaseToInStorageConsumer implements BaseConsumer &#123;</span><br><span class="line"> @Override</span><br><span class="line"> public void consume(Message message, Channel channel) &#123;</span><br><span class="line"> log.debug(&quot;收到消息1: &#123;&#125;&quot;, message.toString());</span><br><span class="line"> PartsBase entity &#x3D; MessageHelper.msgToObj(message, PartsBase.class);</span><br><span class="line"> &#x2F;&#x2F;业务逻辑</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>3.定义代理类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BaseConsumerProxy &#123;</span><br><span class="line"> &#x2F;&#x2F;私有属性</span><br><span class="line"> private Object target;</span><br><span class="line"> private RemoteMsgLogService msgLogService;</span><br><span class="line"> &#x2F;&#x2F;构造方法</span><br><span class="line"> public BaseConsumerProxy(Object target, RemoteMsgLogService msgLogService) &#123;</span><br><span class="line"> this.target &#x3D; target;</span><br><span class="line"> this.msgLogService &#x3D; msgLogService;</span><br><span class="line"> &#125;</span><br><span class="line"> &#x2F;&#x2F;获取代理对象</span><br><span class="line"> public Object getProxy() &#123;</span><br><span class="line"> ClassLoader classLoader &#x3D; target.getClass().getClassLoader();</span><br><span class="line"> Class[] interfaces &#x3D; target.getClass().getInterfaces();</span><br><span class="line"></span><br><span class="line">return Proxy.newProxyInstance(classLoader, interfaces, (proxy, method, args) -&gt; &#123;</span><br><span class="line"> Message message &#x3D; (Message) args[0];</span><br><span class="line"> Channel channel &#x3D; (Channel) args[1];</span><br><span class="line"> MessageProperties properties &#x3D; message.getMessageProperties();</span><br><span class="line"> long tag &#x3D; properties.getDeliveryTag();</span><br><span class="line"> try &#123;</span><br><span class="line"> Object result &#x3D; method.invoke(target, args);</span><br><span class="line"> channel.basicAck(tag, false);</span><br><span class="line"> return result;</span><br><span class="line"> &#125; catch (Exception e) &#123;</span><br><span class="line"> log.error(&quot;getProxy error&quot;, e);</span><br><span class="line"> return null;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>4.使用方式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@RabbitListener(queues &#x3D; PartsBaseMqConstant.PARTS_BASE_TO_IN_STORAGE_QUEUE)</span><br><span class="line">public void partsBaseInStorageConsume(Message message, Channel channel) throws IOException &#123;</span><br><span class="line"> rabbitUtils.doConsume(message, channel, partsBaseInStorageConsumer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void doConsume(Message message, Channel channel, BaseConsumer baseConsumer) throws IOException &#123;</span><br><span class="line"> BaseConsumerProxy baseConsumerProxy &#x3D; new BaseConsumerProxy(baseConsumer, msgLogService);</span><br><span class="line"> BaseConsumer proxy &#x3D; (BaseConsumer) baseConsumerProxy.getProxy();</span><br><span class="line"> if (null !&#x3D; proxy) &#123;</span><br><span class="line"> proxy.consume(message, channel);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>5.解释：<br>　　所有的对象都通过代理类来访问，我要让其中一个队列执行消费功能，那么通过公用代理类来访问，来执行mq的一些操作，比如确认消费啊，报错消费重入队列等操作，因为这些操作都是相同的逻辑所以放到公用代理类里，然后消费者就单纯的执行消费方面的逻辑，比如入库等。当然也可以每一个消费队列都一个消费代理类。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1.简介&quot;&gt;&lt;/a&gt;1.简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;动态代理技术就是用来产生一个对象的代理对象的&lt;/strong&gt;。&lt;br&gt;　1、&lt;strong&gt;代理对象存在的
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mysql语句</title>
    <link href="pangxue.vip/2021/04/11/mysql/"/>
    <id>pangxue.vip/2021/04/11/mysql/</id>
    <published>2021-04-10T17:03:04.000Z</published>
    <updated>2021-04-10T17:27:32.537Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-求每个学生所有学科分最高的是哪科？"><a href="#1-求每个学生所有学科分最高的是哪科？" class="headerlink" title="1.求每个学生所有学科分最高的是哪科？"></a>1.求每个学生所有学科分最高的是哪科？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select student.* from student inner join (select name,max(grade) grade from student group by name ) t on student.name&#x3D;t.name and student.grade&#x3D;t.grade</span><br></pre></td></tr></table></figure><h3 id="2-求每个学科分最高的是那个童鞋？"><a href="#2-求每个学科分最高的是那个童鞋？" class="headerlink" title="2.求每个学科分最高的是那个童鞋？"></a>2.求每个学科分最高的是那个童鞋？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT student.* FROM student inner JOIN ( SELECT subject, max( grade ) grade FROM student GROUP BY subject ) t ON student.subject &#x3D; t.subject AND student.grade &#x3D; t.grade</span><br></pre></td></tr></table></figure><h3 id="3-求数学成绩大于数学整体平均分的同学？"><a href="#3-求数学成绩大于数学整体平均分的同学？" class="headerlink" title="3.求数学成绩大于数学整体平均分的同学？"></a>3.求数学成绩大于数学整体平均分的同学？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select student.* from student where subject &#x3D;&#39;数学&#39; and grade&gt;(select avg(grade) from student where subject&#x3D;&#39;数学&#39;)</span><br></pre></td></tr></table></figure><h3 id="4-求数学平均分大于60分的同学？"><a href="#4-求数学平均分大于60分的同学？" class="headerlink" title="4.求数学平均分大于60分的同学？"></a>4.求数学平均分大于60分的同学？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select student.name from student where subject&#x3D;&#39;数学&#39; group by student.&#96;name&#96; having avg(grade) &gt;60</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-求每个学生所有学科分最高的是哪科？&quot;&gt;&lt;a href=&quot;#1-求每个学生所有学科分最高的是哪科？&quot; class=&quot;headerlink&quot; title=&quot;1.求每个学生所有学科分最高的是哪科？&quot;&gt;&lt;/a&gt;1.求每个学生所有学科分最高的是哪科？&lt;/h3&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="mysql" scheme="pangxue.vip/categories/mysql/"/>
    
    
      <category term="mysql" scheme="pangxue.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>MyBatisCodeHelper-Pro破解[2.8.1]</title>
    <link href="pangxue.vip/2020/05/26/MyBatisCodeHelper/"/>
    <id>pangxue.vip/2020/05/26/MyBatisCodeHelper/</id>
    <published>2020-05-26T02:05:07.000Z</published>
    <updated>2020-05-26T02:08:10.005Z</updated>
    
    <content type="html"><![CDATA[<ol><li>链接: <a href="https://pan.baidu.com/s/1qwOzRupun3uVTw6dQMHB2g" target="_blank" rel="noopener">https://pan.baidu.com/s/1qwOzRupun3uVTw6dQMHB2g</a> 提取码: ebcv 复制这段内容后打开百度网盘手机App，操作更方便哦</li><li><img src="/Mybatis-code-helper-pro%E7%A0%B4%E8%A7%A3/20200526100724106.png" alt=""></li><li><a href="https://zhile.io/2019/04/23/mybatis-code-helper-pro-crack.html" target="_blank" rel="noopener">https://zhile.io/2019/04/23/mybatis-code-helper-pro-crack.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;链接: &lt;a href=&quot;https://pan.baidu.com/s/1qwOzRupun3uVTw6dQMHB2g&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pan.baidu.com/s/1qwOzRupun3uVT
      
    
    </summary>
    
    
    
      <category term="MyBatisCodeHelper" scheme="pangxue.vip/tags/MyBatisCodeHelper/"/>
    
  </entry>
  
  <entry>
    <title>idea配置</title>
    <link href="pangxue.vip/2020/05/21/ideasetting/"/>
    <id>pangxue.vip/2020/05/21/ideasetting/</id>
    <published>2020-05-21T02:17:25.000Z</published>
    <updated>2020-05-21T02:21:38.627Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1：idea破解（更新到2020-1-1版本）"><a href="#1：idea破解（更新到2020-1-1版本）" class="headerlink" title="1：idea破解（更新到2020.1.1版本）"></a>1：idea破解（更新到2020.1.1版本）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链接: https:&#x2F;&#x2F;pan.baidu.com&#x2F;s&#x2F;1CjLBcqQqwQ5Olfc7bF6xwA 提取码: tifc</span><br></pre></td></tr></table></figure><p><strong>使用方式：</strong></p><ul><li><p>下载最新版idea，安装，然后进去试用30天，进入软件**</p></li><li><p>下载上述文件，去lib目录下解压到指定目录，将jetbrains-agent.jar拖到idea中，然后选择Active_Code方式激活即可，如果不好使参考试用说明**</p></li></ul><h2 id="2：开启服务甲板（原dashboard）"><a href="#2：开启服务甲板（原dashboard）" class="headerlink" title="2：开启服务甲板（原dashboard）"></a>2：开启服务甲板（原dashboard）</h2><ul><li><strong>打开项目下.idea-&gt;workspace.xml,找到RunDashboard，添加如下代码保存重启即可</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;component name&#x3D;&quot;RunDashboard&quot;&gt;</span><br><span class="line">  &lt;option name&#x3D;&quot;configurationTypes&quot;&gt;</span><br><span class="line">    &lt;set&gt;</span><br><span class="line">      &lt;option value&#x3D;&quot;SpringBootApplicationConfigurationType&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;set&gt;</span><br><span class="line">  &lt;&#x2F;option&gt;</span><br><span class="line">&lt;&#x2F;component&gt;</span><br></pre></td></tr></table></figure></li><li><strong>对启动的服务添加端口号：删除掉安装自带的快捷方式，把图片中的idea64发送到桌面快捷方式即可</strong></li></ul><h2 id="3：集成mybatis报错"><a href="#3：集成mybatis报错" class="headerlink" title="3：集成mybatis报错"></a>3：集成mybatis报错</h2><p><strong>使用MyBatisCodeHelperPro插件，但是使用时代码飘红，Result type is xxx, Not match for <code>List&lt;xxx&gt;</code>“</strong><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/idea%E9%85%8D%E7%BD%AE/20200521101936798.png" alt=""><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/idea%E9%85%8D%E7%BD%AE/20200521101946687.png" alt=""></p><h2 id="4：P3C插件"><a href="#4：P3C插件" class="headerlink" title="4：P3C插件"></a>4：P3C插件</h2><p>一款阿里爸爸的代码规范，可实时检查，下载地址：<br><a href="https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/10046-alibaba-java-coding-guidelines</a></p><p><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/idea%E9%85%8D%E7%BD%AE/20200521102021109.png" alt=""><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/idea%E9%85%8D%E7%BD%AE/20200521102051144.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1：idea破解（更新到2020-1-1版本）&quot;&gt;&lt;a href=&quot;#1：idea破解（更新到2020-1-1版本）&quot; class=&quot;headerlink&quot; title=&quot;1：idea破解（更新到2020.1.1版本）&quot;&gt;&lt;/a&gt;1：idea破解（更新到2020.
      
    
    </summary>
    
    
    
      <category term="idea" scheme="pangxue.vip/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>Mysql相关</title>
    <link href="pangxue.vip/2020/05/19/aboutmysql/"/>
    <id>pangxue.vip/2020/05/19/aboutmysql/</id>
    <published>2020-05-19T01:09:50.000Z</published>
    <updated>2020-05-26T03:49:43.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-MyISAM引擎"><a href="#1-MyISAM引擎" class="headerlink" title="1. MyISAM引擎"></a>1. MyISAM引擎</h2><p>　　MySQL的表级锁有两种模式：共享读锁（Read-Lock）和排它写锁（Write-Lock）。针对MyISAM表的读操作，不会阻塞其他线程对同一表的读请求，但阻塞对同一表的写请求；针对MyISAM表的写操作，会阻塞其他线程对同一表的读和写操作；MyISAM引擎读写操作之间，以及写与写操作之间是串行化。当一次会话线程获取表的写锁后，只有当前持有锁的会话线程可以对表进行操作。其它线程的读、写操作都会等待，直到锁被释放为止。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 1、加读锁</span><br><span class="line">&#x2F;&#x2F;LOCK TABLE name [READ,WRITE] ;加表锁</span><br><span class="line">&#x2F;&#x2F;UNLOCK TABLES ; 释放表锁</span><br><span class="line">LOCK TABLE dc_user READ ;</span><br><span class="line">-- 2、当前会话查询，OK</span><br><span class="line">SELECT * FROM dc_user ;</span><br><span class="line">-- 4、当前会话写入，Error</span><br><span class="line">INSERT INTO dc_user (user_name,tell_phone) VALUES (&#39;lock01&#39;,&#39;13267788998&#39;);</span><br><span class="line">-- 6、查询其他表,Error</span><br><span class="line">SELECT * FROM dc_user_info ;</span><br><span class="line">-- 7、释放锁</span><br><span class="line">UNLOCK TABLES ;</span><br></pre></td></tr></table></figure><h2 id="２-InnoDB引擎"><a href="#２-InnoDB引擎" class="headerlink" title="２. InnoDB引擎"></a>２. InnoDB引擎</h2><p>InnoDB支持事物，支持行级锁</p><ul><li><strong>事务概念</strong><br>事务是指作为单个逻辑工作单元执行的一系列操作（SQL语句）。这些操作要么全部成功，要么全部不成功。</li><li><strong>事务特性ACID</strong></li><li><em>原子性(Atomicity)*</em>：事务中的多个操作要么都成功要么都失败</li><li><em>一致性(consistency)*</em>：事务的执行的前后数据的完整性保持一致</li><li><em>隔离性(isolation)*</em>：事务执行的过程中,不应该受到其他事务的干扰</li><li><em>持久性(durability)*</em>：事务一旦结束,数据就持久到数据库</li><li><strong>事务问题</strong></li><li><em>脏读*</em>：一个事务读到另一个事务没有提交的数据</li><li><em>不可重复读*</em>：一个事务前后多次读取相同数据，数据内容不一致，update场景问题</li><li><em>虚读(幻读)*</em>：一个事务前后多次读取，数据总量不一致，insert场景问题</li><li><strong>隔离级别</strong></li><li><em>read uncommitted*</em>：事务可以读取另一个未提交事务的数据。</li><li><em>read committed*</em>：事务要等另一个事务提交后才能读取数据,解决脏读。</li><li><em>repeatable read*</em>：在开始读取数据时,事务开启,不再允许修改操作,解决：脏读、不可重复读。</li><li><em>serializable*</em>：最高事务隔离级别，事务串行化顺序执行，解决脏读、不可重复读、幻读。但是效率低下，耗数据库性能。</li><li><strong>锁</strong></li><li><em>1.共享锁：*</em>又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。若事务T对数据对象A加上共享锁，则事务T可以读A但不能修改A，其他事务只能再对A加共享锁，而不能加写锁，直到T释放A上的共享锁。这保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。</li><li><em>2.排他锁：*</em>又称写锁。允许获取排他锁的事务更新数据，阻止其他事务取得相同的资源的共享读锁和排他锁。若事务T对数据对象A加上写锁，事务T可以读A也可以修改A，其他事务不能再对A加任何锁，直到T释放A上的写锁。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 1、关闭自动提交</span><br><span class="line">SET AUTOCOMMIT &#x3D; 0 ;</span><br><span class="line">-- 2、查询id&#x3D;2，OK</span><br><span class="line">SELECT * FROM dc_user_in02 WHERE id&#x3D;2 ;</span><br><span class="line">-- 3、查询id&#x3D;1，OK，加读锁</span><br><span class="line">SELECT * FROM dc_user_in02 WHERE id&#x3D;1 ;</span><br><span class="line">-- 4、写入成功</span><br><span class="line">INSERT INTO dc_user_in02 (user_name,tell_phone) VALUES (&#39;lock01&#39;,&#39;13267788998&#39;);</span><br><span class="line">-- 5、加写锁成功，id为2的</span><br><span class="line">SELECT * FROM dc_user_in02 </span><br><span class="line">WHERE id&#x3D;2 FOR UPDATE ;</span><br><span class="line">-- 6、加写锁失败(等待)，占用id为1的</span><br><span class="line">SELECT * FROM dc_user_in02 WHERE id&#x3D;1 FOR UPDATE ;</span><br><span class="line">-- 7、恢复事务提交</span><br><span class="line">SET AUTOCOMMIT&#x3D;1 ;</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-悲观锁"><a href="#3-悲观锁" class="headerlink" title="3.悲观锁"></a>3.悲观锁</h2><p>适用于写操作较多，读操作较少的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from user where uid&#x3D;l for update;&#x2F;&#x2F;行锁</span><br><span class="line">update user set name&#x3D;bac where uid&#x3D;l;&#x2F;&#x2F;更新完释放这条锁</span><br></pre></td></tr></table></figure><h2 id="4-乐观锁"><a href="#4-乐观锁" class="headerlink" title="4. 乐观锁"></a>4. 乐观锁</h2><p>乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><ul><li><strong>1、使用版本号实现乐观锁</strong><br>给表增加一个数字类型的 “version” 字段，当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加 1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的version值进行比对，如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数据。<strong>注意：乐观锁的更新操作，最好用主键或者唯一索引来更新,这样是行锁，否则更新时会锁表</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update xxx set aaa&#x3D;111,version&#x3D;version+1 where id&#x3D;#&#123;id&#125; and version&#x3D;#&#123;version&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>2、乐观锁锁库存防止超买超卖</strong><br>  version乐观锁能控制并发，但是不能控制数量的超卖问题  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">update res_stock</span><br><span class="line">set number &#x3D;number + #&#123;resStockVo.operateNumber&#125;,</span><br><span class="line">   version&#x3D;#&#123;resStockVo.version&#125; + 1</span><br><span class="line">where id &#x3D; #&#123;resStockVo.id&#125;</span><br><span class="line">  and number + #&#123;resStockVo.operateNumber&#125; &gt;&#x3D; 0</span><br><span class="line">  and version &#x3D; #&#123;resStockVo.version&#125;</span><br></pre></td></tr></table></figure></li><li><strong>3、mybatis plus实现乐观锁</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;注册bean</span><br><span class="line">@Bean</span><br><span class="line">public OptimisticLockerInterceptor optimisticLockerInterceptor() &#123;</span><br><span class="line">   return new OptimisticLockerInterceptor();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;实体里添加 @Version 注解，*   仅支持 &#96;updateById(id)&#96; 与 &#96;update(entity, wrapper)&#96; 方法</span><br></pre></td></tr></table></figure></li><li><strong>4、乐观锁添加重试机制</strong>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;重试注解</span><br><span class="line">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface OptimisticLock &#123;</span><br><span class="line">   int retryTimes() default 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Aspect</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class RetryAspect &#123;</span><br><span class="line"></span><br><span class="line">   @Around(&quot;@annotation(lock)&quot;)</span><br><span class="line">   @Transactional(rollbackFor &#x3D; Exception.class)</span><br><span class="line">   public Object doConcurrentOperation(ProceedingJoinPoint pjp, OptimisticLock lock) throws Throwable &#123;</span><br><span class="line">      int retryTimes &#x3D; 0;</span><br><span class="line">      int MaxRetryTimes &#x3D; lock.retryTimes();</span><br><span class="line">      while (retryTimes &lt;&#x3D; MaxRetryTimes) &#123;</span><br><span class="line">         retryTimes++;</span><br><span class="line">         try &#123;</span><br><span class="line">            &#x2F;&#x2F;再次执行</span><br><span class="line">            return pjp.proceed();</span><br><span class="line">         &#125; catch (OptimisticLockException ex) &#123;</span><br><span class="line">            if (retryTimes &gt; MaxRetryTimes) &#123;</span><br><span class="line">               &#x2F;&#x2F;如果大于默认的重试机制 次数，我们这回就真正的抛出去了</span><br><span class="line">               throw new RuntimeException(ex.getMessage());</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">               log.info(&quot;当前正在重试第：&quot; + retryTimes + &quot;次&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;注册bean</span><br><span class="line">@Bean</span><br><span class="line">public RetryAspect retryAspect() &#123;</span><br><span class="line">   return new RetryAspect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-MyISAM引擎&quot;&gt;&lt;a href=&quot;#1-MyISAM引擎&quot; class=&quot;headerlink&quot; title=&quot;1. MyISAM引擎&quot;&gt;&lt;/a&gt;1. MyISAM引擎&lt;/h2&gt;&lt;p&gt;　　MySQL的表级锁有两种模式：共享读锁（Read-Lock）和排它写
      
    
    </summary>
    
    
    
      <category term="mysql" scheme="pangxue.vip/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>线程相关</title>
    <link href="pangxue.vip/2020/05/08/aboutthread/"/>
    <id>pangxue.vip/2020/05/08/aboutthread/</id>
    <published>2020-05-08T02:26:16.000Z</published>
    <updated>2020-05-21T02:08:06.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1.线程安全"></a>1.线程安全</h2><ul><li><p>线程安全：多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。</p></li><li><p>线程不安全：不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p></li><li><p>线程安全问题都是由<strong>多个线程访问同一个共享资源的写操作</strong>引起的。比如一个 ArrayList 类，如果是在多线程情况下，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向 ArrayList 添加元素，因为此时 Size 仍然等于 0 ，所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。</p></li><li><p>对于Integer，++ 操作是不安全的，所以java提供了原子操作类 AtomicInteger 来实现自增等操作</p></li><li><p>静态方法：如果方法内部不操作类的静态变量或者全局变量，那么该方法是线程安全的，如果操作了，那么需要加锁来实现线程安全。</p></li><li><p>解决方法：</p><ul><li><p>锁：<br>每个java对象都可以用做一个实现同步的锁，这些锁成为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。</p></li><li><p>乐观锁和悲观锁：</p><ul><li>悲观锁：在整个数据处理过程中，将数据处于锁定状态，传统关系型数据库里面的很多锁就是采用的这种机制,例如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。java里面的synchronize和ReentrantLock等重入锁就是采用的这种机制。</li><li>乐观锁：在更新时会判断其他线程在这之前有没有对数据进行修改，一般会使用版本号机制或CAS操作实现在Java中java.util.concurrent.atomic包下面的原子变量类就是使用CAS实现的：实现方式<br>1:<code>update t_goods set status=2,version=version+1where id=#{id} and version=#{version};</code><br>2:<code>UPDATE t_goodsSET num = num - #{buyNum} WHERE id = #{id} AND num - #{buyNum} &gt;= 0 AND STATUS = 1</code><br>这两种办法都可以实现，第一种需要额外拓展一个version的字段，第二种适合不用版本号，只更新是做数据安全校验，适合库存模型，扣份额和回滚份额，性能更高。</li></ul></li><li><p>类锁和对象锁：<br>synchronized 加到 static 方法前面是给 class 加锁，即类锁；而synchronized 加到非静态方法前面是给对象上锁。对象锁和类锁是不同的锁，所以多个线程同时执行这2个不同锁的方法时，是异步的。类锁对该类的所有对象都能起作用，而对象锁不能</p></li><li><p>synchronized修饰方法：直接对方法上锁，第一个线程占用之后其他线程必须等待其释放，当方法内业务逻辑复杂时，影响系统运行性能，不会出现数据脏读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public synchronized int increamentAndGet() &#123;</span><br><span class="line">   System.out.println(&quot;当前余票&quot; + (100 - i));</span><br><span class="line">   i++;</span><br><span class="line">   return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/20200508015339556.png" alt=""></p></li><li><p>synchronized修代码块：不锁方法，锁要类的对象,但是并不能保证线程调用的方法体同步执行（同步代码块中执行是同步的）,线程会优先读取被锁住的代码块，代码块内保证了真正的同步，代码块外部还是并发，就会出现数据脏读，例如下图余票</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int increamentAndGet() &#123;</span><br><span class="line">   System.out.println(&quot;当前余票&quot;+(100-i));</span><br><span class="line">   synchronized (this)&#123;</span><br><span class="line">      System.out.println(&quot;当前真实的余票&quot;+(100-i));</span><br><span class="line">      i++;</span><br><span class="line">      return i;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/20200508015203936.png" alt=""> </p></li><li><p>lock</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock &#x3D; new ReentrantLock();</span><br><span class="line">public int increamentAndGet() &#123;</span><br><span class="line">   System.out.println(&quot;当前余票&quot; + (100 - i));</span><br><span class="line">   lock.lock();</span><br><span class="line">   System.out.println(&quot;当前真实的余票&quot; + (100 - i));</span><br><span class="line">   i++;</span><br><span class="line">   lock.unlock();</span><br><span class="line">   return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">      private int i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">      public int increamentAndGet() &#123;</span><br><span class="line">         System.out.println(&quot;当前余票&quot; + (100 - i));</span><br><span class="line">         synchronized (this) &#123;</span><br><span class="line">            System.out.println(&quot;当前真实的余票&quot; + (100 - i));</span><br><span class="line">            i++;</span><br><span class="line">            return i;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void thread(Test code) &#123;</span><br><span class="line">         while (true) &#123;</span><br><span class="line">            System.out.println(&quot;用户&quot; + Thread.currentThread().getName() + &quot;买了第&quot; + code.increamentAndGet() + &quot;张票&quot;);</span><br><span class="line">            try &#123;</span><br><span class="line">               Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">               e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   public static void main(String[] args) &#123;</span><br><span class="line">      Test code &#x3D; new Test();</span><br><span class="line">      ExecutorService executorService &#x3D; Executors.newCachedThreadPool();</span><br><span class="line">      executorService.execute(() -&gt; code.thread(code));</span><br><span class="line">      executorService.execute(() -&gt; code.thread(code));</span><br><span class="line">      executorService.execute(() -&gt; code.thread(code));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h2><ol><li>使用场景：<ul><li>数据库连接池的设计一般也是采用单例模式</li><li>多线程的线程池的设计一般也是采用单例模式，这是由于线程池要方便对池中的线程进行控制。</li><li>Windows的Task Manager（任务管理器）就是很典型的单例模式（这个很熟悉吧），想想看，是不是呢，你能打开两个windows task manager吗？ 不信你自己试试看哦~</li><li>Web应用的配置对象的读取，一般也应用单例模式，这个是由于配置文件是共享的资源。</li></ul></li><li>实现方式：<ul><li>饿汉式：非懒加载，线程安全。明确需要实例化的情况下使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">   private Singleton ()&#123;&#125;</span><br><span class="line">   private static Singleton instance &#x3D; new Singleton();</span><br><span class="line">   public static Singleton getInstance() &#123;</span><br><span class="line">      return instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>双重校验锁：懒加载，线程安全。采用双锁机制，安全且在多线程情况下能保持高性能。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">  public class Singleton &#123;</span><br><span class="line">   private Singleton ()&#123;&#125;</span><br><span class="line">   private volatile static Singleton singleton;</span><br><span class="line">   public static Singleton getSingleton() &#123;</span><br><span class="line">      if (singleton &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;第一重</span><br><span class="line">         synchronized (Singleton.class) &#123;</span><br><span class="line">            if (singleton &#x3D;&#x3D; null) &#123;&#x2F;&#x2F;第二重</span><br><span class="line">               singleton &#x3D; new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return singleton;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>静态内部类：懒加载，线程安全。明确需要懒加载或者实例化特别耗内存的时候使用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  public class Singleton &#123;</span><br><span class="line">   private static class SingletonHolder &#123;</span><br><span class="line">      private static final Singleton INSTANCE &#x3D; new Singleton();</span><br><span class="line">   &#125;</span><br><span class="line">   private Singleton ()&#123;&#125;</span><br><span class="line">   public static final Singleton getInstance() &#123;</span><br><span class="line">      return SingletonHolder.INSTANCE;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h2 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3. 线程池"></a>3. 线程池</h2><ul><li><p><strong>1. 线程池介绍：</strong><br>  执行一个异步任务我们可能只是如下new Thread：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  jdk8之后可以用lambda</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    new Thread(() -&gt; System.out.println(Thread.currentThread().getName())).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  <strong>但是阿里规范不提尝使用Executors创建线程池</strong><br>  <img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/20200520095113867.png" alt=""></p></li><li><p><strong>2. 自定义线程池：</strong><br>  CPU密集型：操作内存处理的业务，一般线程数设置为：CPU核数 + 1 或者 CPU核数*2。核数为4的话，一般设置 5 或 8<br>  IO密集型：文件操作，网络操作，数据库操作，一般线程设置为：cpu核数 / (1-0.9)，核数为4的话，一般设置 40</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">自定义线程池构造方法</span><br><span class="line">ExecutorService pool1 &#x3D; new ThreadPoolExecutor(CPUCoreCount * 4, CPUCoreCount * 8, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(), new ThreadPoolExecutor.DiscardPolicy());</span><br></pre></td></tr></table></figure></li><li><p><strong>3. 参数解释：</strong></p><ul><li>1、核心数<br>线程池维护线程的最少数量，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达到corePoolSize后，就会把到达的任务放到缓存队列当中。</li><li>2、最大数<br>线程池维护线程的最大数量，它表示在线程池中最多能创建多少个线程；这个参数是跟后面的阻塞队列联系紧密的；只有当阻塞队列满了，如果还有任务添加到线程池的话，会尝试new 一个Thread的进行救急处理，立马执行对应的runnable任务；如果继续添加任务到线程池，且线程池中的线程数已经达到了maximumPoolSize，那么线程就会就会执行reject操作。</li><li>3、存活时间<br>线程池维护线程所允许的空闲时间，表示线程没有任务执行时最多保持多久时间会终止；默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用；即当线程池中的线程数大于corePoolSize时，如果一个线程空闲的时间达到keepAliveTime，则会终止，直到线程池中的线程数不超过corePoolSize。但是如果调用了allowCoreThreadTimeOut(boolean)方法并设置了参数为true，在线程池中的线程数不大于corePoolSize时，keepAliveTime参数也会起作用，直到线程池中的阻塞队列大小为0；（这部分通过查看ThreadPoolExecutor的源码分析–getTask()部分）</li><li>4、时间单位<br>线程池维护线程所允许的空闲时间的单位，参数keepAliveTime的时间单位，有7种取值，在TimeUnit类中有7种静态属性（时间单位）。</li><li>5、缓冲队列<br>线程池所使用的缓冲队列，用来存储等待执行的任务，这个参数的选择也很重要，会对线程池的运行过程产生重大影响，一般来说，这里的阻塞队列有以下几种选择<br>ArrayBlockingQueue;<br>LinkedBlockingQueue;<br>SynchronousQueue;<br>ArrayBlockingQueue和PriorityBlockingQueue使用较少，一般使用LinkedBlockingQueue和Synchronous。线程池的排队策略与BlockingQueue有关。</li><li>6、决绝策略<br>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。（默认handle）<br>ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。<br>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）<br>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务。</li></ul></li><li><p><strong>4. 执行流程：</strong><br>当一个任务通过execute(Runnable)方法欲添加到线程池时：</p><ul><li>1、如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li><li>2、如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。</li><li>3、如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</li><li>4、如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，则会使用handler处理被拒绝的任务。</li><li>5、当线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样以来，线程池可以动态的调整池中的线程数</li><li>参考：<br><a href="https://juejin.im/post/5b25b3d0f265da597d0a9803#heading-17" target="_blank" rel="noopener">https://juejin.im/post/5b25b3d0f265da597d0a9803#heading-17</a></li></ul></li><li><p><strong>5. 自定义线程名称：</strong><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/20200521095959581.png" alt=""><br>还是遭受到阿里爸爸的毒打，来吧继续，选中黄色提示按2次 ctrl + F1 先看看阿里爸爸的提示：<br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/20200521100703410.png" alt=""><br>可以按照这个写，也可以自定义线程工厂来拓展：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 命名线程工厂</span><br><span class="line">  static class NamedThreadFactory implements ThreadFactory &#123;</span><br><span class="line">      private static final AtomicInteger poolNumber &#x3D; new AtomicInteger(1);</span><br><span class="line">      private final ThreadGroup group;</span><br><span class="line">      private final AtomicInteger threadNumber &#x3D; new AtomicInteger(1);</span><br><span class="line">      private final String namePrefix;</span><br><span class="line"></span><br><span class="line">      NamedThreadFactory(String name) &#123;</span><br><span class="line"></span><br><span class="line">          SecurityManager s &#x3D; System.getSecurityManager();</span><br><span class="line">          group &#x3D; (s !&#x3D; null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">          if (null &#x3D;&#x3D; name || name.isEmpty()) &#123;</span><br><span class="line">              name &#x3D; &quot;pool&quot;;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          namePrefix &#x3D; name + &quot;-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public Thread newThread(Runnable r) &#123;</span><br><span class="line">          Thread t &#x3D; new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0);</span><br><span class="line">          if (t.isDaemon())</span><br><span class="line">              t.setDaemon(false);</span><br><span class="line">          if (t.getPriority() !&#x3D; Thread.NORM_PRIORITY)</span><br><span class="line">              t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">          return t;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static ThreadPoolExecutor executorOne &#x3D; new ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES,</span><br><span class="line">            new LinkedBlockingQueue&lt;&gt;(), new NamedThreadFactory(&quot;Test-Pool&quot;));</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-线程安全&quot;&gt;&lt;a href=&quot;#1-线程安全&quot; class=&quot;headerlink&quot; title=&quot;1.线程安全&quot;&gt;&lt;/a&gt;1.线程安全&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;线程安全：多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程
      
    
    </summary>
    
    
    
      <category term="thread" scheme="pangxue.vip/tags/thread/"/>
    
  </entry>
  
  <entry>
    <title>springcloud相关</title>
    <link href="pangxue.vip/2020/05/07/aboutspringcloud/"/>
    <id>pangxue.vip/2020/05/07/aboutspringcloud/</id>
    <published>2020-05-07T02:37:39.000Z</published>
    <updated>2020-05-07T09:26:04.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Feign相关"><a href="#1-Feign相关" class="headerlink" title="1.Feign相关"></a>1.Feign相关</h2><ol><li><strong>404：检查<code>RequestMapping</code>路径是否正确</strong></li><li><strong>Request method ‘POST’ not supported：</strong><br> 参数是对象时候需要注意：<br> <img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/springcloud%E7%9B%B8%E5%85%B3/20200507032710306.png" alt=""><ul><li>参数需要实现序列化</li><li>并且需要使用<code>PostMapping</code>,同样的控制层也需要是<code>PostMapping</code></li><li>如果对象里面又包含对象，或者<code>list</code>，数组等,需要加<code>@RequestBody</code>把数据绑定到bean上</li><li><code>@RequestBody</code>注解常用来处理<code>content-type</code>不是默认的<code>application/x-www-form-urlcoded</code>编码的内容，比如说：<code>application/json</code>类型。</li></ul></li><li><strong><code>feign</code>远程调用，使用get方式：</strong><ul><li>不能使用对象传递参数。</li><li>在所有参数前加上<code>@RequestParam</code>注解，或者通过<code>@PathVariable</code>获取。</li><li>指明为GET方式<br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/springcloud%E7%9B%B8%E5%85%B3/20200507044339611.png" alt=""><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/springcloud%E7%9B%B8%E5%85%B3/20200507044502419.png" alt=""></li></ul></li><li><strong><code>feign</code>远程调用，使用post方式：</strong><ul><li>有且只有一个参数前为<code>@RequestBody</code>或什么也没有</li><li>如果有多个参数，那么其余参数前必须有<code>@RequestParam</code></li><li>如果参数前什么也不写，那么默认是由<code>@RequestBody</code>指明的,这样不满足<code>get</code>请求，只能是<code>post</code>传递<br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/springcloud%E7%9B%B8%E5%85%B3/20200507044802358.png" alt=""><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/springcloud%E7%9B%B8%E5%85%B3/20200507044853243.png" alt=""></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Feign相关&quot;&gt;&lt;a href=&quot;#1-Feign相关&quot; class=&quot;headerlink&quot; title=&quot;1.Feign相关&quot;&gt;&lt;/a&gt;1.Feign相关&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;404：检查&lt;code&gt;RequestMapping&lt;/
      
    
    </summary>
    
    
    
      <category term="springcloud" scheme="pangxue.vip/tags/springcloud/"/>
    
  </entry>
  
  <entry>
    <title>数据重复校验</title>
    <link href="pangxue.vip/2020/04/29/check-data-repeat/"/>
    <id>pangxue.vip/2020/04/29/check-data-repeat/</id>
    <published>2020-04-29T06:01:10.000Z</published>
    <updated>2020-04-29T10:41:07.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-利用aop实现。"><a href="#1-利用aop实现。" class="headerlink" title="1.利用aop实现。"></a>1.利用aop实现。</h2><ul><li><p><strong>注意</strong>：如果在微服务中想做成公用模块，那么可以新建个专门的工具模块来存放这些功能，然后不要生成web项目，通过spring 的工厂引入bean<br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%A0%A1%E9%AA%8C/20200429020256104.png" alt=""></p></li><li><p><strong>配置文件装配bean：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class ToolAutoConfiguration &#123;</span><br><span class="line">   @Bean</span><br><span class="line">  public CheckAspect checkAspect() &#123;</span><br><span class="line">      return new CheckAspect();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>spring.factories配置代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;\</span><br><span class="line"> com.xxx.xxx.common.tool.ToolAutoConfiguration</span><br></pre></td></tr></table></figure></li><li><p><strong>切片实现代码：</strong></p><ul><li><p>*<em>1.通过注解实现（控制层加注解，再进入请求方法之前就能执行，aop拦截注解，取出注解定义好的bean） *</em><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%A0%A1%E9%AA%8C/20200429063329065.png" alt=""><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%A0%A1%E9%AA%8C/20200429063419140.png" alt=""></p></li><li><p><strong>2.通过切点实现 （直接切service服务）</strong><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%A0%A1%E9%AA%8C/20200429063610254.png" alt=""></p></li><li><p><strong>完整切面逻辑代码</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@Aspect</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">public class CheckAspect &#123;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"> * @param: [joinPoint, checkRepeat]</span><br><span class="line"> * @return: void</span><br><span class="line"> * @description : aop 自定义注解实现校验（在进入方法前就可以判断，推荐）</span><br><span class="line">  **&#x2F;</span><br><span class="line">  @Before(value &#x3D; &quot;@annotation(checkRepeatValidator)&quot;)</span><br><span class="line">   public void checkRepeat(JoinPoint joinPoint, CheckRepeatValidator checkRepeatValidator) throws IllegalAccessException, InstantiationException &#123;</span><br><span class="line">      IService iService &#x3D; (IService)SpringContextUtil.getBean(checkRepeatValidator.service());</span><br><span class="line">      Object entityObj &#x3D; checkRepeatValidator.entity().newInstance();</span><br><span class="line">      Object vo &#x3D; joinPoint.getArgs()[0];</span><br><span class="line">      BeanUtils.copyProperties(vo, entityObj);</span><br><span class="line">      check(iService, entityObj);</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;**</span><br><span class="line"> * @param: [joinPoint]</span><br><span class="line"> * @return: void</span><br><span class="line"> * @description : aop 切点实现（只能在调用保存方法后才出发，与上述注解实现选其一）</span><br><span class="line">  **&#x2F;</span><br><span class="line">  @Before(value &#x3D; &quot;execution(* com.bluecloud.kebest.*.service.*.save*(..)) || execution(* com.bluecloud.kebest.*.service.*.update*(..)) &quot;)</span><br><span class="line">   public void checkRepeat(JoinPoint joinPoint) throws IllegalAccessException &#123;</span><br><span class="line">      Object entityObj &#x3D; joinPoint.getArgs()[0];</span><br><span class="line">      ServiceImpl iService &#x3D; (ServiceImpl) joinPoint.getTarget();</span><br><span class="line">      if (entityObj.getClass().isAnnotationPresent(CheckRepeat.class)) &#123;</span><br><span class="line">         check(iService, entityObj);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private void check(IService iService, Object entityObj) throws IllegalAccessException &#123;</span><br><span class="line">      QueryWrapper queryWrapper &#x3D; new QueryWrapper();</span><br><span class="line">      Field[] declaredFields &#x3D; entityObj.getClass().getDeclaredFields();</span><br><span class="line">      StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line">      Object id &#x3D; null;</span><br><span class="line">      for (Field field : declaredFields) &#123;</span><br><span class="line">         CheckRepeat annotation &#x3D; field.getAnnotation(CheckRepeat.class);</span><br><span class="line">         if (annotation !&#x3D; null) &#123;</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            String fieldName &#x3D; field.getName();</span><br><span class="line">            Object fieldVal &#x3D; field.get(entityObj);</span><br><span class="line">            ApiModelProperty info &#x3D; field.getAnnotation(ApiModelProperty.class);</span><br><span class="line">            String fieldChineseName &#x3D; info.value();</span><br><span class="line">            CheckTypeEnum checkTypeEnum &#x3D; annotation.checkType();</span><br><span class="line">            if (checkTypeEnum &#x3D;&#x3D; CheckTypeEnum.eachCheck) &#123;</span><br><span class="line">               queryWrapper.or();</span><br><span class="line">            &#125;</span><br><span class="line">            queryWrapper.eq(CamelConvert.camel2Underline(fieldName), fieldVal);</span><br><span class="line">            builder.append(&quot;,&quot; + fieldChineseName);</span><br><span class="line">         &#125;</span><br><span class="line">         if (field.getName().equals(&quot;id&quot;)) &#123;</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            id &#x3D; field.get(entityObj);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      builder.delete(0, 1);</span><br><span class="line">      int count &#x3D; iService.count(queryWrapper);</span><br><span class="line">      &#x2F;&#x2F;通过id是否为null来判断是新增还是编辑，编辑的情况要排除自身</span><br><span class="line">  if (id !&#x3D; null) &#123;</span><br><span class="line">         count--;</span><br><span class="line">      &#125;</span><br><span class="line">      if (count &gt; 0) &#123;</span><br><span class="line">         throw new RuntimeException(builder.toString() + &quot;已被占用,请重新填写&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-使用validation校验"><a href="#2-使用validation校验" class="headerlink" title="2.使用validation校验"></a>2.使用validation校验</h2></li></ul></li><li><p><strong>控制层入参开启 @validated 注解</strong><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%A0%A1%E9%AA%8C/20200429020519036.png" alt=""></p></li><li><p>*<em>由于控制层校验的是vo，需指明校验的entity *</em><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%A0%A1%E9%AA%8C/20200429020611261.png" alt=""></p></li><li><p>*<em>entity继承 mybatis-plus 的 Model *</em><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%A0%A1%E9%AA%8C/20200429020628524.png" alt=""><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%A0%A1%E9%AA%8C/20200429020637065.png" alt=""></p></li><li><p>*<em>entity 设置校验类型（图为联合校验，2个字段保证唯一） *</em><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%A0%A1%E9%AA%8C/20200429020659840.png" alt=""></p></li><li><p>*<em>注解上指明校验的类 *</em><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%A0%A1%E9%AA%8C/20200429020716902.png" alt=""></p></li><li><p>*<em>校验的类实现 ConstraintValidator并调用工具类做业务处理 *</em><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%A0%A1%E9%AA%8C/20200429020739103.png" alt=""><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E6%A0%A1%E9%AA%8C/20200429020809356.png" alt=""></p></li><li><p>**<a href="https://github.com/ok3754792/tool" target="_blank" rel="noopener">详细代码地址</a> **</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-利用aop实现。&quot;&gt;&lt;a href=&quot;#1-利用aop实现。&quot; class=&quot;headerlink&quot; title=&quot;1.利用aop实现。&quot;&gt;&lt;/a&gt;1.利用aop实现。&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果在微服务中想做
      
    
    </summary>
    
    
    
      <category term="aop,validation" scheme="pangxue.vip/tags/aop-validation/"/>
    
  </entry>
  
  <entry>
    <title>树形结构</title>
    <link href="pangxue.vip/2020/04/27/tree/"/>
    <id>pangxue.vip/2020/04/27/tree/</id>
    <published>2020-04-27T09:41:11.000Z</published>
    <updated>2020-04-27T09:43:47.421Z</updated>
    
    <content type="html"><![CDATA[<ul><li>利用map特性，但是需要对父级id排序<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T extends TreeNode&gt; List&lt;T&gt; buildAccordMap(List&lt;T&gt; treeNodes, Object root) &#123;</span><br><span class="line">   MapT&gt; map &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">   MapT&gt; collect &#x3D; treeNodes.stream().collect(Collectors.toMap(T::getId, obj -&gt; obj));</span><br><span class="line">   treeNodes.sort(Comparator.comparing(T::getParentId));</span><br><span class="line">   treeNodes.forEach(n -&gt; &#123;</span><br><span class="line">      if (root.equals(n.getParentId())) &#123;</span><br><span class="line">         map.put(n.getId(), n);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">         T child &#x3D; collect.get(n.getParentId());</span><br><span class="line">         child.getChildren().add(n);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   List&lt;T&gt; newList &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">   map.forEach((k, v) -&gt; newList.add(v));</span><br><span class="line">   return newList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>2层for循环<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public &lt;T extends TreeNode&gt; List&lt;T&gt; build(List&lt;T&gt; treeNodes, Object root) &#123;</span><br><span class="line">   List&lt;T&gt; trees &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">   for (T treeNode : treeNodes) &#123;</span><br><span class="line">      if (root.equals(treeNode.getParentId())) &#123;</span><br><span class="line">         trees.add(treeNode);</span><br><span class="line">      &#125;</span><br><span class="line">      for (T it : treeNodes) &#123;</span><br><span class="line">         if (it.getParentId() &#x3D;&#x3D; treeNode.getId()) &#123;</span><br><span class="line">            if (treeNode.getChildren() &#x3D;&#x3D; null) &#123;</span><br><span class="line">               treeNode.setChildren(new ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            treeNode.add(it);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return trees;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;利用map特性，但是需要对父级id排序&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;l
      
    
    </summary>
    
    
    
      <category term="树形结构" scheme="pangxue.vip/tags/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>gitlab相关</title>
    <link href="pangxue.vip/2020/04/27/gitlab/"/>
    <id>pangxue.vip/2020/04/27/gitlab/</id>
    <published>2020-04-27T06:48:48.000Z</published>
    <updated>2020-04-29T06:09:43.392Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-强制回退版本"><a href="#1-强制回退版本" class="headerlink" title="1. 强制回退版本"></a>1. 强制回退版本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard fb479960c0cec5549463ae123d70bdd72ccf6be7</span><br><span class="line">git push -f origin master</span><br></pre></td></tr></table></figure><h4 id="2-本地新项目上传到git已有项目中"><a href="#2-本地新项目上传到git已有项目中" class="headerlink" title="2. 本地新项目上传到git已有项目中"></a>2. 本地新项目上传到git已有项目中</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &#39;first commit&#39;</span><br><span class="line">git remote add origin 你的远程库地址</span><br><span class="line">git pull --rebase origin master</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/gitlab%E7%9B%B8%E5%85%B3/20200429115942798.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-强制回退版本&quot;&gt;&lt;a href=&quot;#1-强制回退版本&quot; class=&quot;headerlink&quot; title=&quot;1. 强制回退版本&quot;&gt;&lt;/a&gt;1. 强制回退版本&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
    
      <category term="gitlab" scheme="pangxue.vip/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>EasyExcel踩坑</title>
    <link href="pangxue.vip/2020/04/24/EasyExcel/"/>
    <id>pangxue.vip/2020/04/24/EasyExcel/</id>
    <published>2020-04-24T07:40:45.000Z</published>
    <updated>2020-04-24T08:38:54.890Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Could-not-initialize-class-com-alibaba-excel-write-ExcelBuilderImpl"><a href="#1-Could-not-initialize-class-com-alibaba-excel-write-ExcelBuilderImpl" class="headerlink" title="1. Could not initialize class com.alibaba.excel.write.ExcelBuilderImpl"></a>1. Could not initialize class com.alibaba.excel.write.ExcelBuilderImpl</h4><ul><li>解决办法：跟poi依赖冲突，easyexcel底层使用poi了</li></ul><h4 id="2-Can-not-find-‘Converter’-support-class-LocalDateTime"><a href="#2-Can-not-find-‘Converter’-support-class-LocalDateTime" class="headerlink" title="2. Can not find ‘Converter’ support class LocalDateTime."></a>2. Can not find ‘Converter’ support class LocalDateTime.</h4><ul><li><p>解决办法：LocalDateTime 属于jdk8.所以暂时不支持。这个需要自己自定义转换器。</p></li><li><p><strong>1：注解</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.FIELD&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">public @interface LocalDateTimeFormat &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line"> * 指定LocalDateTime转化的日期格式</span><br><span class="line">  * 例如 : &quot;yyyy-MM-dd HH:mm:ss&quot;,导入导出都会将LocalDateTime转化为对应格式字符串</span><br><span class="line">  *</span><br><span class="line"> * @return 日期格式</span><br><span class="line">  *&#x2F;</span><br><span class="line">  String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>2：转化器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public class LocalDateTimeExcelConverter implements Converter &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 不使用&#123;@code @LocalDateTimeFormat&#125;注解指定日期格式时,默认会使用该格式.</span><br><span class="line"> **&#x2F;  </span><br><span class="line"> private static final String DEFAULT_PATTERN &#x3D; &quot;yyyy&#x2F;MM&#x2F;dd HH:mm:ss&quot;;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">  public Class supportJavaTypeKey() &#123;</span><br><span class="line">      return LocalDateTime.class;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">  public CellDataTypeEnum supportExcelTypeKey() &#123;</span><br><span class="line">      return CellDataTypeEnum.STRING;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 这里读的时候会调用</span><br><span class="line"> * @param cellData excel数据 (NotNull)</span><br><span class="line"> * @param contentProperty excel属性 (Nullable)</span><br><span class="line"> * @param globalConfiguration 全局配置 (NotNull)</span><br><span class="line"> * @return 读取到内存中的数据</span><br><span class="line"> * *&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public LocalDateTime convertToJavaData(CellData cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) &#123;</span><br><span class="line">      LocalDateTimeFormat annotation &#x3D; contentProperty.getField().getAnnotation(LocalDateTimeFormat.class);</span><br><span class="line">      return LocalDateTime.parse(cellData.getStringValue(),</span><br><span class="line">            DateTimeFormatter.ofPattern(Objects.nonNull(annotation) ? annotation.value() : DEFAULT_PATTERN));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 写的时候会调用</span><br><span class="line"> * @param value java value (NotNull)</span><br><span class="line"> * @param contentProperty excel属性 (Nullable)</span><br><span class="line"> * @param globalConfiguration 全局配置 (NotNull)</span><br><span class="line"> * @return 写出到excel文件的数据</span><br><span class="line"> **&#x2F;</span><br><span class="line">  @Override</span><br><span class="line">  public CellData convertToExcelData(LocalDateTime value, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) &#123;</span><br><span class="line">      LocalDateTimeFormat annotation &#x3D; contentProperty.getField().getAnnotation(LocalDateTimeFormat.class);</span><br><span class="line">      return new CellData(value.format(DateTimeFormatter.ofPattern(Objects.nonNull(annotation) ? annotation.value() : DEFAULT_PATTERN)));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>3：工具类：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">public class EasyExcelUtil &#123;</span><br><span class="line">   private static OutputStream getOutputStream(String fileName) throws IOException &#123;</span><br><span class="line">      HttpServletResponse response &#x3D; ((ServletRequestAttributes) Objects.requireNonNull(RequestContextHolder.getRequestAttributes())).getResponse();</span><br><span class="line">      if (response !&#x3D; null) &#123;</span><br><span class="line">         fileName &#x3D; URLEncoder.encode(fileName, &quot;UTF-8&quot;);</span><br><span class="line">         response.setHeader(&quot;Content-Disposition&quot;, &quot;attachment;filename&#x3D;&quot; + fileName + &quot;.xls&quot;);&#x2F;&#x2F; 指定下载的文件名</span><br><span class="line">  response.setContentType(&quot;application&#x2F;vnd.ms-excel&quot;);</span><br><span class="line">         return response.getOutputStream();</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#x2F;**</span><br><span class="line"> * @param fileName 文件名称</span><br><span class="line">  * @param sheetName 表格名称</span><br><span class="line">  * @param list 查询数据list</span><br><span class="line"> * @param  list泛型</span><br><span class="line">  * @description web直接下载报表util，样式这里能设置一部门，列宽列高都在泛型类里设置</span><br><span class="line">  *&#x2F;</span><br><span class="line">  public static &lt;T&gt; void webDownloadExcel(String fileName, String sheetName, List&lt;T&gt; list) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">         OutputStream out &#x3D; getOutputStream(fileName);</span><br><span class="line">         &#x2F;&#x2F; 头的策略</span><br><span class="line">  WriteCellStyle headWriteCellStyle &#x3D; new WriteCellStyle();</span><br><span class="line">         &#x2F;&#x2F; 背景设置为红色</span><br><span class="line">  &#x2F;&#x2F;headWriteCellStyle.setFillForegroundColor(IndexedColors.RED.getIndex());</span><br><span class="line">  WriteFont headWriteFont &#x3D; new WriteFont();</span><br><span class="line">         headWriteFont.setFontHeightInPoints((short) 12);</span><br><span class="line">         headWriteCellStyle.setWriteFont(headWriteFont);</span><br><span class="line">         &#x2F;&#x2F; 内容的策略</span><br><span class="line">  WriteCellStyle contentWriteCellStyle &#x3D; new WriteCellStyle();</span><br><span class="line">         &#x2F;&#x2F; 这里需要指定 FillPatternType 为FillPatternType.SOLID_FOREGROUND 不然无法显示背景颜色.头默认了 FillPatternType所以可以不指定</span><br><span class="line">  &#x2F;&#x2F;contentWriteCellStyle.setFillPatternType(FillPatternType.SOLID_FOREGROUND);</span><br><span class="line"> &#x2F;&#x2F; 背景绿色</span><br><span class="line">  &#x2F;&#x2F;contentWriteCellStyle.setFillForegroundColor(IndexedColors.GREEN.getIndex());</span><br><span class="line">  WriteFont contentWriteFont &#x3D; new WriteFont();</span><br><span class="line">         &#x2F;&#x2F; 字体大小</span><br><span class="line">  contentWriteFont.setFontHeightInPoints((short) 11);</span><br><span class="line">         contentWriteCellStyle.setWriteFont(contentWriteFont);</span><br><span class="line">         &#x2F;&#x2F; 这个策略是 头是头的样式 内容是内容的样式 其他的策略可以自己实现</span><br><span class="line">  HorizontalCellStyleStrategy horizontalCellStyleStrategy &#x3D;</span><br><span class="line">               new HorizontalCellStyleStrategy(headWriteCellStyle, contentWriteCellStyle);</span><br><span class="line">         if (list !&#x3D; null &amp;&amp; list.size() &gt; 0) &#123;</span><br><span class="line">            EasyExcel.write(out, list.get(0).getClass()).registerWriteHandler(horizontalCellStyleStrategy).sheet(sheetName).doWrite(list);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">         log.error(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>4：使用方式：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ExcelProperty(value &#x3D; &quot;创建时间&quot;, converter &#x3D; LocalDateTimeExcelConverter.class)</span><br><span class="line">@LocalDateTimeFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-Could-not-initialize-class-com-alibaba-excel-write-ExcelBuilderImpl&quot;&gt;&lt;a href=&quot;#1-Could-not-initialize-class-com-alibaba-excel-writ
      
    
    </summary>
    
    
    
      <category term="EasyExcel" scheme="pangxue.vip/tags/EasyExcel/"/>
    
  </entry>
  
  <entry>
    <title>aop校验数据重复</title>
    <link href="pangxue.vip/2020/04/22/aopCheckRepeat/"/>
    <id>pangxue.vip/2020/04/22/aopCheckRepeat/</id>
    <published>2020-04-22T10:08:07.000Z</published>
    <updated>2021-03-07T07:36:18.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-切的是service层，save或者update开头的实现类。"><a href="#1-切的是service层，save或者update开头的实现类。" class="headerlink" title="1.切的是service层，save或者update开头的实现类。"></a>1.切的是service层，save或者update开头的实现类。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;</span><br><span class="line">import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;</span><br><span class="line">import com.bluecloud.kebest.common.core.anno.CheckRepeatAnno;</span><br><span class="line">import com.bluecloud.kebest.common.core.util.CamelConvert;</span><br><span class="line">import org.aspectj.lang.JoinPoint;</span><br><span class="line">import org.aspectj.lang.annotation.Aspect;</span><br><span class="line">import org.aspectj.lang.annotation.Before;</span><br><span class="line">import org.aspectj.lang.annotation.Pointcut;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line">@Aspect</span><br><span class="line">@Component</span><br><span class="line">public class CheckAspect &#123;</span><br><span class="line"></span><br><span class="line">   @Pointcut(&quot;execution(* com.bluecloud.kebest.storage.service.*.save*(..)) || execution(* com.bluecloud.kebest.storage.service.*.update*(..)) &quot;)</span><br><span class="line">   private void checkRepeatPointCut() &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Before(value &#x3D; &quot;checkRepeatPointCut()&quot;)</span><br><span class="line">   public void checkRepeat(JoinPoint joinPoint) throws IllegalAccessException &#123;</span><br><span class="line">      Object param &#x3D; joinPoint.getArgs()[0];</span><br><span class="line">      Object target &#x3D; joinPoint.getTarget();</span><br><span class="line">      Class paramClass &#x3D; param.getClass();</span><br><span class="line">      ServiceImpl iService &#x3D; (ServiceImpl) target;</span><br><span class="line">      QueryWrapper queryWrapper &#x3D; new QueryWrapper&lt;&gt;();</span><br><span class="line">      Field[] declaredFields &#x3D; paramClass.getDeclaredFields();</span><br><span class="line">      StringBuilder builder &#x3D; new StringBuilder();</span><br><span class="line">      boolean flag &#x3D; false;</span><br><span class="line">      for (Field field : declaredFields) &#123;</span><br><span class="line">         CheckRepeatAnno annotation &#x3D; field.getAnnotation(CheckRepeatAnno.class);</span><br><span class="line">         if (annotation !&#x3D; null) &#123;</span><br><span class="line">            flag &#x3D; true;</span><br><span class="line">            field.setAccessible(true);</span><br><span class="line">            String fieldName &#x3D; field.getName();</span><br><span class="line">            Object fieldVal &#x3D; field.get(param);</span><br><span class="line">            queryWrapper.eq(CamelConvert.camel2Underline(fieldName), fieldVal);</span><br><span class="line">            builder.append(fieldName + &quot; &quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if (flag) &#123;</span><br><span class="line">         int count &#x3D; iService.count(queryWrapper);</span><br><span class="line">         if (count &gt; 0) &#123;</span><br><span class="line">            throw new RuntimeException(builder.toString() + &quot;数据重复&quot;);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-切的是service层，save或者update开头的实现类。&quot;&gt;&lt;a href=&quot;#1-切的是service层，save或者update开头的实现类。&quot; class=&quot;headerlink&quot; title=&quot;1.切的是service层，save或者update
      
    
    </summary>
    
    
    
      <category term="aop" scheme="pangxue.vip/tags/aop/"/>
    
  </entry>
  
  <entry>
    <title>lambda常用写法</title>
    <link href="pangxue.vip/2020/04/20/aboutlambda/"/>
    <id>pangxue.vip/2020/04/20/aboutlambda/</id>
    <published>2020-04-20T02:47:30.000Z</published>
    <updated>2021-04-10T17:43:10.651Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-lambda简介"><a href="#1-lambda简介" class="headerlink" title="1.lambda简介"></a>1.lambda简介</h3><p>　　Lambda 表达式，也可称为闭包,包含以下特性：</p><ul><li><strong>可选类型声明：</strong>不需要声明参数类型，编译器可以统一识别参数值。</li><li><strong>可选的参数圆括号：</strong>一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li><strong>可选的大括号：</strong>如果主体包含了一个语句，就不需要使用大括号。</li><li><strong>可选的返回关键字：</strong>如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li><li><strong>作用域：</strong>只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量</li></ul><h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h3><ol><li>数组排序：<code>Arrays.sort(players, (String s1, String s2) -&gt; (s1.compareTo(s2)));</code></li><li>集合排序正序：<code>depListso.sort(Comparator.comparing(AuthorizeTree::getSort));</code></li><li>集合排序倒序：<code>depListso.sort(Comparator.comparing(AuthorizeTree::getSort).reversed());</code></li></ol><h3 id="3-流式"><a href="#3-流式" class="headerlink" title="3.流式"></a>3.流式</h3><ul><li><p><strong>1.过滤（filter）：</strong><br><code>records.stream().filter(n -&gt; (n.getId() &gt; 1 &amp;&amp; n.getStatus() .length()==2)).collect(Collectors.toList());</code></p></li><li><p><strong>2.匹配（allMatch）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean b &#x3D; records.stream().allMatch(n -&gt; n.getId() &gt; 1)</span><br><span class="line">List&lt;String&gt; strs &#x3D; Arrays.asList(&quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;b&quot;);</span><br><span class="line">        boolean aa &#x3D; strs.stream().anyMatch(str -&gt; str.equals(&quot;a&quot;));&#x2F;&#x2F; TRUE</span><br><span class="line">        boolean bb &#x3D; strs.stream().allMatch(str -&gt; str.equals(&quot;a&quot;));&#x2F;&#x2F; FALSE</span><br><span class="line">        boolean cc &#x3D; strs.stream().noneMatch(str -&gt; str.equals(&quot;a&quot;));&#x2F;&#x2F; FALSE</span><br><span class="line">        long count &#x3D; strs.stream().filter(str -&gt; str.equals(&quot;a&quot;)).count();&#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure></li><li><p><strong>3.转换（map）</strong><br><code>records.stream().map(LocationVo::getCode).collect(Collectors.toList())</code></p></li><li><p><strong>4.运算（reduce）</strong><br><code>String s = records.stream().map(LocationVo::getCode).reduce((x, y) -&gt; x + y).get();</code></p></li><li><p><strong>5.最大最小（max，min）</strong><br><code>LocalDate maxDate = dates.stream().max( Comparator.comparing( LocalDate::toEpochDay ) ).get();</code>　　</p></li><li><p><strong>6.收集器（collect）</strong><br><code>data.stream().collect(Collectors.toMap(UserVO::getUserId,n-&gt;n, (k1, k2) -&gt; k1))</code>　　</p></li><li><p><strong>7.list转map（）</strong><br><code>data.stream().collect(Collectors.toMap(UserVO::getUserId,n-&gt;n, (k1, k2) -&gt; k1))</code>　　<br>toMap第一个参数：key，第二个参数：value，第三个参数：如果重复取第一个key</p></li><li><p><strong>8.list转map（分组）</strong><br><code>Map&lt;String, List&lt;SysDictItem&gt;&gt; collect = list.stream().collect(Collectors.groupingBy(SysDictItem::getType));</code></p></li><li><p><strong>9.list转map（进阶）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List&lt;PartsInStorageDetailVo&gt; list&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">Map&lt;Integer, List&lt;Integer&gt;&gt; partIdsMap &#x3D; list.stream().collect(Collectors.toMap(</span><br><span class="line">      PartsInStorageDetailVo::getInStorageId, val -&gt; &#123;</span><br><span class="line">         List&lt;Integer&gt; ids &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line">         ids.add(val.getPartsId());</span><br><span class="line">         return ids;</span><br><span class="line">      &#125;, (k1, k2) -&gt; &#123;</span><br><span class="line">         k1.addAll(k2);</span><br><span class="line">         return k1.stream().distinct().collect(Collectors.toList());</span><br><span class="line">      &#125;</span><br><span class="line">));</span><br><span class="line">&#x2F;&#x2F;针对对象的其中两个属性进行分组，分组后如果key重复那么并集</span><br></pre></td></tr></table></figure></li><li><p><strong>10. 两个list求交集，差集</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (needEnums !&#x3D; null &amp;&amp; !needEnums.isEmpty()) &#123;</span><br><span class="line">&#x2F;&#x2F;交集</span><br><span class="line">   return needEnums.stream().filter(allFieldEnums::contains).collect(Collectors.toList());</span><br><span class="line">&#125; else if (notNeedEnums !&#x3D; null &amp;&amp; !notNeedEnums.isEmpty()) &#123;</span><br><span class="line">&#x2F;&#x2F;差集</span><br><span class="line">   return allFieldEnums.stream().filter(n -&gt; !notNeedEnums.contains(n)).collect(Collectors.toList());</span><br><span class="line">&#125; else &#123;</span><br><span class="line">   return allFieldEnums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="11"><li>list对象某个字段拼接起来<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String cutterCodes &#x3D; cutterList.stream().map(PartsMachiningCutterDetailVo::getCutterCode).collect(Collectors.joining(&quot;,&quot;));</span><br></pre></td></tr></table></figure></li><li>list对象某个属性去重<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkFinalVoList &#x3D; checkFinalVoList.stream().collect(Collectors.collectingAndThen(Collectors.toCollection(() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(CheckFinalVo::getOrderId))), ArrayList::new));</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-lambda简介&quot;&gt;&lt;a href=&quot;#1-lambda简介&quot; class=&quot;headerlink&quot; title=&quot;1.lambda简介&quot;&gt;&lt;/a&gt;1.lambda简介&lt;/h3&gt;&lt;p&gt;　　Lambda 表达式，也可称为闭包,包含以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
    
    
      <category term="lambda" scheme="pangxue.vip/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>idea中mybatis常见设置</title>
    <link href="pangxue.vip/2020/04/17/idea-mybatis-general-setting/"/>
    <id>pangxue.vip/2020/04/17/idea-mybatis-general-setting/</id>
    <published>2020-04-17T03:02:29.000Z</published>
    <updated>2020-04-17T03:59:40.239Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-推荐使用MyBatisCodeHelperPro插件，但是使用时代码飘红，Result-type-is-xxx-Not-match-for-List-lt-xxx-gt-“"><a href="#1-推荐使用MyBatisCodeHelperPro插件，但是使用时代码飘红，Result-type-is-xxx-Not-match-for-List-lt-xxx-gt-“" class="headerlink" title="1.推荐使用MyBatisCodeHelperPro插件，但是使用时代码飘红，Result type is xxx, Not match for List&lt;xxx&gt;“"></a>1.推荐使用MyBatisCodeHelperPro插件，但是使用时代码飘红，Result type is xxx, Not match for <code>List&lt;xxx&gt;</code>“</h3><p><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/idea%E4%B8%ADmybatis%E5%B8%B8%E8%A7%81%E8%AE%BE%E7%BD%AE/20200417111819749.png" alt=""><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/idea%E4%B8%ADmybatis%E5%B8%B8%E8%A7%81%E8%AE%BE%E7%BD%AE/20200417111657697.png" alt=""><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/idea%E4%B8%ADmybatis%E5%B8%B8%E8%A7%81%E8%AE%BE%E7%BD%AE/20200417111402381.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-推荐使用MyBatisCodeHelperPro插件，但是使用时代码飘红，Result-type-is-xxx-Not-match-for-List-lt-xxx-gt-“&quot;&gt;&lt;a href=&quot;#1-推荐使用MyBatisCodeHelperPro插件，但是使
      
    
    </summary>
    
    
    
      <category term="ideaSetting" scheme="pangxue.vip/tags/ideaSetting/"/>
    
  </entry>
  
  <entry>
    <title>java新建父子项目</title>
    <link href="pangxue.vip/2020/04/14/module/"/>
    <id>pangxue.vip/2020/04/14/module/</id>
    <published>2020-04-14T07:56:16.000Z</published>
    <updated>2020-04-14T08:04:12.623Z</updated>
    
    <content type="html"><![CDATA[<p> <img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/java%E6%96%B0%E5%BB%BA%E7%88%B6%E5%AD%90%E9%A1%B9%E7%9B%AE/20200414035818510.png" alt=""><br> <img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/java%E6%96%B0%E5%BB%BA%E7%88%B6%E5%AD%90%E9%A1%B9%E7%9B%AE/20200414035854973.png" alt=""><br> <img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/java%E6%96%B0%E5%BB%BA%E7%88%B6%E5%AD%90%E9%A1%B9%E7%9B%AE/20200414040025659.png" alt=""><br> <img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/java%E6%96%B0%E5%BB%BA%E7%88%B6%E5%AD%90%E9%A1%B9%E7%9B%AE/20200414040124512.png" alt=""><br> <img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/java%E6%96%B0%E5%BB%BA%E7%88%B6%E5%AD%90%E9%A1%B9%E7%9B%AE/20200414040253912.png" alt=""><br> <img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/java%E6%96%B0%E5%BB%BA%E7%88%B6%E5%AD%90%E9%A1%B9%E7%9B%AE/20200414040336829.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; &lt;img src=&quot;http://hexo-1258128768.cos.ap-beijing.myqcloud.com/java%E6%96%B0%E5%BB%BA%E7%88%B6%E5%AD%90%E9%A1%B9%E7%9B%AE/2020041403581851
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>idea插件</title>
    <link href="pangxue.vip/2020/04/14/aboutlombok/"/>
    <id>pangxue.vip/2020/04/14/aboutlombok/</id>
    <published>2020-04-14T07:41:56.000Z</published>
    <updated>2020-04-15T06:15:44.546Z</updated>
    
    <content type="html"><![CDATA[<p>首先，用到的几个注解：</p><h1 id="1-Lombok"><a href="#1-Lombok" class="headerlink" title="1.Lombok"></a>1.Lombok</h1><h3 id="Data"><a href="#Data" class="headerlink" title="@Data"></a>@Data</h3><p>　　使用这个注解，就不用再去手写Getter,Setter,equals,canEqual,hasCode,toString等方法了，注解后在编译时会自动加进去。</p><h3 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h3><p>　　使用后添加一个构造函数，该构造函数含有所有已声明字段属性参数，在controller里或者无需使用@Resource注解注入service<br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/lombok%E7%9B%B8%E5%85%B3/20200414035120048.png" alt=""></p><h3 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor"></a>@NoArgsConstructor</h3><p>　　使用后创建一个无参构造函数</p><h1 id="2-Free-Mybatis-plugin"><a href="#2-Free-Mybatis-plugin" class="headerlink" title="2. Free Mybatis plugin"></a>2. Free Mybatis plugin</h1><p><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/lombok%E7%9B%B8%E5%85%B3/20200415021506389.png" alt=""><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/lombok%E7%9B%B8%E5%85%B3/20200415021525279.png" alt=""><br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/lombok%E7%9B%B8%E5%85%B3/20200415021534182.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先，用到的几个注解：&lt;/p&gt;
&lt;h1 id=&quot;1-Lombok&quot;&gt;&lt;a href=&quot;#1-Lombok&quot; class=&quot;headerlink&quot; title=&quot;1.Lombok&quot;&gt;&lt;/a&gt;1.Lombok&lt;/h1&gt;&lt;h3 id=&quot;Data&quot;&gt;&lt;a href=&quot;#Data&quot; 
      
    
    </summary>
    
    
    
      <category term="idea插件" scheme="pangxue.vip/tags/idea%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Mysql优化心得</title>
    <link href="pangxue.vip/2020/04/06/sqlOptimization/"/>
    <id>pangxue.vip/2020/04/06/sqlOptimization/</id>
    <published>2020-04-06T03:12:11.000Z</published>
    <updated>2020-04-06T10:13:13.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-建表基础向"><a href="#1-建表基础向" class="headerlink" title="1. 建表基础向"></a>1. 建表基础向</h2><p>　　1. 字段精度尽量精确，能用int就不用varchar，能用tinyint就不用int<br>　　2. null用数字代替<br>　　3. 枚举类可用数字代替</p><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><p>　　1. 索引不宜多，常用的where，order by字段索引<br>　　2. 避免索引上的null的判断，比较<br>　　3. varchar比较大的可以试试前缀索引<br>　　4. 联合索引和单索引重叠时，可以删除单索引，注意顺序</p><h2 id="3-sql向"><a href="#3-sql向" class="headerlink" title="3. sql向"></a>3. sql向</h2><p>　　1. 不要在sql中运算，运算放在程序里<br>　　2. 小数据in是可以走索引的<br>　　3. 存储过程，触发器，时间尽量在程序中实现<br>　　4. join on的字段类型要保持一致</p><h2 id="4-简单水平分区"><a href="#4-简单水平分区" class="headerlink" title="4. 简单水平分区"></a>4. 简单水平分区</h2><p>　　1. 数据分散，对大表数据最简单的优化方案，通常基于时间分区（Range分区），并且开始设置每天，月自动执行分区。查询时加上时间范围很快。<br>　　2. 如果某个字段有特殊的意义会导致经常访问，那么可以按照这个逻辑把这个数据放到单独的分区表中，或者缓存到缓存中</p><h2 id="5-垂直分库"><a href="#5-垂直分库" class="headerlink" title="5. 垂直分库"></a>5. 垂直分库</h2><p>　　把大表常用字段和不常用字段垂直拆开，分为两个表，或者多个表。只能使行数据变小但是无法解决单表数据量过大的问题，而且要维护主键，维护代码</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-建表基础向&quot;&gt;&lt;a href=&quot;#1-建表基础向&quot; class=&quot;headerlink&quot; title=&quot;1. 建表基础向&quot;&gt;&lt;/a&gt;1. 建表基础向&lt;/h2&gt;&lt;p&gt;　　1. 字段精度尽量精确，能用int就不用varchar，能用tinyint就不用int&lt;br
      
    
    </summary>
    
    
      <category term="MYSQL" scheme="pangxue.vip/categories/MYSQL/"/>
    
    
      <category term="sql优化" scheme="pangxue.vip/tags/sql%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>springboot+security+JWT</title>
    <link href="pangxue.vip/2020/03/28/springboot+security+JWT/"/>
    <id>pangxue.vip/2020/03/28/springboot+security+JWT/</id>
    <published>2020-03-28T02:04:31.000Z</published>
    <updated>2020-04-05T06:51:07.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>　　<code>security</code>是企业级安全框架，可用于用户认证,实现前后分离权限注解，通过JWT登录认证</p><h2 id="2-教程"><a href="#2-教程" class="headerlink" title="2. 教程"></a>2. 教程</h2><p>   教程： <code>https://mp.weixin.qq.com/s/v6qUncrHI09S2s3GroTe7w</code></p><h2 id="3-配置jwt"><a href="#3-配置jwt" class="headerlink" title="3. 配置jwt"></a>3. 配置jwt</h2><p>　　jwt相关属性可配置在配置文件中<br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/springboot%2Bsecurity%2BJWT/20200402102236995.png" alt=""></p><h2 id="3-jwt配置类的映射model"><a href="#3-jwt配置类的映射model" class="headerlink" title="3. jwt配置类的映射model"></a>3. jwt配置类的映射model</h2><p>　　需要注意：<br><img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/springboot%2Bsecurity%2BJWT/20200402101752754.png" alt=""><br>并且要注意下propertySource注解的 <code>factory = YamlPropertySourceFactory.class</code>,这个是专门为了yml配置文件注入<br>　　<img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/springboot%2Bsecurity%2BJWT/20200402102053361.png" alt=""></p><h2 id="４-单点登陆："><a href="#４-单点登陆：" class="headerlink" title="４. 单点登陆："></a>４. 单点登陆：</h2><p>　　实质上就是刷新token，并且保证之前的token失效，如果使用redis存储token就又变得有状态了，违反了设计初衷，放在数据库中每次都要查询，浪费资源。目前好香米有什么好的解决办法</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;p&gt;　　&lt;code&gt;security&lt;/code&gt;是企业级安全框架，可用于用户认证,实现前后分离权限注解，通过JWT登录认证
      
    
    </summary>
    
    
      <category term="java" scheme="pangxue.vip/categories/java/"/>
    
    
      <category term="springboot" scheme="pangxue.vip/tags/springboot/"/>
    
      <category term="security" scheme="pangxue.vip/tags/security/"/>
    
      <category term="JWT" scheme="pangxue.vip/tags/JWT/"/>
    
  </entry>
  
  <entry>
    <title>swagger踩坑</title>
    <link href="pangxue.vip/2020/03/27/java-swagger/"/>
    <id>pangxue.vip/2020/03/27/java-swagger/</id>
    <published>2020-03-27T14:32:44.000Z</published>
    <updated>2020-04-02T14:06:41.119Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前情提要"><a href="#1-前情提要" class="headerlink" title="1. 前情提要"></a>1. 前情提要</h2><p>　　请按照以下地址配置：　<code>https://blog.csdn.net/weixin_33690963/article/details/92055964</code></p><h2 id="2-启动失败"><a href="#2-启动失败" class="headerlink" title="2. 启动失败"></a>2. 启动失败</h2><p>　　项目启动，注册bean失败，打包失败，由于项目使用了mp2，发现是model映射字段出问题了，开启驼峰自动映射之后一定要注意字段名字问题</p><h2 id="3-swagger首页空白"><a href="#3-swagger首页空白" class="headerlink" title="3. swagger首页空白"></a>3. swagger首页空白</h2><p>　　swagger访问页面空白，发开F12,发现swagger-ui.html页面404，由于项目使用了security，说明被拦截了，打开JWT配置文件添加以下设置<img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/swagger%E8%B8%A9%E5%9D%91/20200401113239647.png" alt=""></p><h2 id="3-页面404"><a href="#3-页面404" class="headerlink" title="3. 页面404"></a>3. 页面404</h2><p>　　参考：<code>https://blog.csdn.net/ljm_csdn/article/details/87615670</code>，一定是管理资源的 WebMvcConfiguration 在其他配置类里被占用了，我的事在 json 配置类里占用的<br>  <img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/swagger%E8%B8%A9%E5%9D%91/20200401113932793.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-前情提要&quot;&gt;&lt;a href=&quot;#1-前情提要&quot; class=&quot;headerlink&quot; title=&quot;1. 前情提要&quot;&gt;&lt;/a&gt;1. 前情提要&lt;/h2&gt;&lt;p&gt;　　请按照以下地址配置：　&lt;code&gt;https://blog.csdn.net/weixin_3369
      
    
    </summary>
    
    
      <category term="java" scheme="pangxue.vip/categories/java/"/>
    
    
      <category term="swagger" scheme="pangxue.vip/tags/swagger/"/>
    
  </entry>
  
  <entry>
    <title>Hexo工具（三）</title>
    <link href="pangxue.vip/2020/03/27/HexoTools/"/>
    <id>pangxue.vip/2020/03/27/HexoTools/</id>
    <published>2020-03-27T00:59:16.000Z</published>
    <updated>2020-03-27T02:36:25.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-为什么使用HexoEditor"><a href="#1-为什么使用HexoEditor" class="headerlink" title="1. 为什么使用HexoEditor?"></a>1. 为什么使用HexoEditor?</h2><p>　　1.这个软件有腾讯云的存储桶，也就是oss，配置好文件后一键上传图片很方便。<br>　　2.可以直接新建post，不用频繁的输入命令，只需定义新建post模板即可<br>　　3.一边写一边可以预览，样式不对了可以及时调整</p><h2 id="2-下载与安装"><a href="#2-下载与安装" class="headerlink" title="2. 下载与安装"></a>2. 下载与安装</h2><p>　　链接: <a href="https://pan.baidu.com/s/1nmvkEE4kKeQ-9wIbX3hiGA" target="_blank" rel="noopener">https://pan.baidu.com/s/1nmvkEE4kKeQ-9wIbX3hiGA</a> 提取码: r6yx<br>  为什么不用最新版？最新版新建post没有标头</p><h2 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h2><ol><li>创建腾讯云密钥<br><code>https://console.cloud.tencent.com/cam/capi</code><br>点击新建密钥即可</li><li>　　<img src="http://hexo-1258128768.cos.ap-beijing.myqcloud.com/Hexo%E5%B7%A5%E5%85%B7%EF%BC%88%E4%B8%89%EF%BC%89/20200327101542155.png" alt=""><ol><li>默认资源库：存放本地图片的地方，自定义</li><li>access key：腾讯云的API密钥管理的<code>SecretId</code></li><li>secret key：腾讯云的API密钥管理的<code>SecretKey</code></li><li>上述填对之后其他存储空间，域名会自动填写</li></ol></li></ol><hr><h2 id="4-上传图片"><a href="#4-上传图片" class="headerlink" title="4. 上传图片"></a>4. 上传图片</h2><p>右键编辑页面，点击 <code>上传 腾讯云</code>,会把全部文件上传到腾讯云</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-为什么使用HexoEditor&quot;&gt;&lt;a href=&quot;#1-为什么使用HexoEditor&quot; class=&quot;headerlink&quot; title=&quot;1. 为什么使用HexoEditor?&quot;&gt;&lt;/a&gt;1. 为什么使用HexoEditor?&lt;/h2&gt;&lt;p&gt;　　1.这个
      
    
    </summary>
    
    
      <category term="教程" scheme="pangxue.vip/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="pangxue.vip/tags/hexo/"/>
    
      <category term="HexoEditor" scheme="pangxue.vip/tags/HexoEditor/"/>
    
      <category term="ide" scheme="pangxue.vip/tags/ide/"/>
    
  </entry>
  
</feed>
